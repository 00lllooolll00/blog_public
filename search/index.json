[{"content":"GD25Q40E Flash 存储器驱动 一个针对兆易创新 GD25Q40E 4Mbit SPI Flash 存储器的完整驱动程序，支持标准的 SPI 接口通信和各种存储操作。\n源码下载 GD25Q40E.c GD25Q40E.h 📋 特性概述 完整协议支持: 实现所有 GD25Q40E 标准指令集 多种读写模式: 支持标准读、快速读、页编程等功能 灵活擦除选项: 提供扇区(4KB)、块(32KB/64KB)和整片擦除 电源管理: 支持低功耗模式和唤醒功能 设备识别: 可读取制造商ID、设备ID和唯一ID 错误检查: 包含地址边界检查和参数验证 🏗️ 硬件连接 SPI 接口连接 1 2 3 4 5 6 7 8 9 10 GD25Q40E MCU ───────────────────── CS (Pin 1) → GPIO Output (片选) SO (Pin 2) → SPI MISO WP (Pin 3) → VCC (写保护禁用) GND (Pin 4) → GND SI (Pin 5) → SPI MOSI SCK (Pin 6) → SPI SCK HOLD (Pin 7) → VCC (保持禁用) VCC (Pin 8) → 3.3V 必要配置 在 SysConfig.h 中定义硬件配置：\n1 2 3 #define FLASH_SPI_PORT GPIOA // 片选端口 #define FLASH_SPI_SS_SF GPIO_PIN_4 // 片选引脚 extern SPI_HandleTypeDef hspi1; // SPI 句柄 🔧 快速开始 1. 初始化 Flash 1 2 3 4 5 6 7 8 9 #include \u0026#34;GD25Q40E.h\u0026#34; // 初始化并检测Flash uint32_t flash_id = GD25Q40E_Init(); if (flash_id == 0xC84013) { printf(\u0026#34;GD25Q40E 初始化成功\\n\u0026#34;); } else { printf(\u0026#34;Flash 检测失败: 0x%06lX\\n\u0026#34;, flash_id); } 2. 基本读写操作 1 2 3 4 5 6 7 // 写入数据 uint8_t write_data[] = {0x01, 0x02, 0x03, 0x04}; GD25Q40E_WriteData(write_data, 0x1000, sizeof(write_data)); // 读取数据 uint8_t read_data[4]; GD25Q40E_ReadBytes(read_data, 0x1000, sizeof(read_data)); 3. 擦除操作 1 2 3 4 5 // 擦除一个扇区 (4KB) GD25Q40E_EraseSector(0x1000); // 擦除整个芯片 GD25Q40E_EraseChip(); 📊 存储结构 参数 数值 说明 总容量 512KB 4Mbit 页大小 256字节 编程最小单位 扇区大小 4KB 擦除最小单位 32K块大小 32KB 块擦除选项 64K块大小 64KB 块擦除选项 地址范围 0x00000-0x7FFFF 24位地址 🎯 API 参考 初始化函数 GD25Q40E_Init() - 初始化并检测Flash设备 GD25Q40E_ReadID() - 读取设备ID (预期值: 0xC84013) 数据读取 GD25Q40E_ReadBytes() - 标准模式读取数据 GD25Q40E_FastReadByte() - 快速模式读取数据 数据写入 GD25Q40E_PageProgram() - 页编程 (256字节/页) GD25Q40E_WriteData() - 自动处理跨页写入 擦除操作 GD25Q40E_EraseSector() - 擦除4KB扇区 GD25Q40E_EraseBlock32K() - 擦除32KB块 GD25Q40E_EraseBlock64K() - 擦除64KB块 GD25Q40E_EraseChip() - 整片擦除 电源管理 GD25Q40E_PowerDown() - 进入低功耗模式 GD25Q40E_WakeUp() - 从低功耗模式唤醒 设备信息 GD25Q40E_ReadREMS() - 读取REMS ID GD25Q40E_ReadUniqueID() - 读取唯一ID ⚙️ 移植指南 1. 修改硬件配置 在 GD25Q40E.c 中修改硬件相关宏：\n1 2 #define WTRITE_PIN(__PORT__, __PIN__, __VALUE) HAL_GPIO_WritePin(__PORT__, __PIN__, __VALUE) #define Delay_1ms(X) HAL_Delay(X) 2. 实现SPI通信函数 修改 GD25Q40E_TransmitReceiveData() 函数以匹配您的SPI驱动：\n1 2 3 4 5 6 7 static uint8_t GD25Q40E_TransmitReceiveData(uint8_t txdata) { uint8_t rxdata = 0; // 替换为您的SPI收发函数 HAL_SPI_TransmitReceive(GD25Q40E_SPI, \u0026amp;txdata, \u0026amp;rxdata, 1, HAL_MAX_DELAY); return rxdata; } 3. 配置SPI句柄 在 GD25Q40E.h 中指定使用的SPI句柄：\n1 #define GD25Q40E_SPI \u0026amp;hspi1 // 修改为您的SPI句柄 💡 使用示例 存储配置数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 typedef struct { uint32_t magic; uint8_t version; uint16_t checksum; } config_t; config_t config = {0xAA55AA55, 0x01, 0}; // 写入配置数据 GD25Q40E_EraseSector(0x0000); GD25Q40E_WriteData((uint8_t*)\u0026amp;config, 0x0000, sizeof(config)); // 读取验证 config_t read_config; GD25Q40E_ReadBytes((uint8_t*)\u0026amp;read_config, 0x0000, sizeof(read_config)); 数据日志记录 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void log_data(uint32_t timestamp, float temperature) { static uint32_t log_address = 0x1000; uint8_t log_entry[8]; memcpy(log_entry, \u0026amp;timestamp, 4); memcpy(log_entry + 4, \u0026amp;temperature, 4); GD25Q40E_WriteData(log_entry, log_address, 8); log_address += 8; if (log_address \u0026gt;= 0x2000) { log_address = 0x1000; // 循环写入 GD25Q40E_EraseSector(0x1000); } } ⚠️ 注意事项 写保护: 确保WP引脚接高电平以禁用写保护 擦除必要: 写入前必须擦除目标区域（变为0xFF） 页边界: 单次写入不能跨页边界，使用 GD25Q40E_WriteData() 自动处理 操作等待: 擦除和写入操作需要时间，使用内置等待机制 电压匹配: 确保使用3.3V电压供电和信号电平 🔍 故障排除 常见问题 初始化失败: 检查SPI连接、片选引脚的配置 写入失败: 确认写使能序列正确执行 数据错误: 验证地址没有越界，确保区域已擦除 调试建议 1 2 3 4 5 6 7 // 检查设备ID uint32_t id = GD25Q40E_ReadID(); printf(\u0026#34;Device ID: 0x%06lX\\n\u0026#34;, id); // 检查状态寄存器 uint8_t status = GD25Q40E_ReadStatusReg(); printf(\u0026#34;Status: 0x%02X\\n\u0026#34;, status); 📝 版本历史 v0.1 (2025-08-13) 初始版本发布 实现所有基本功能 添加详细的错误检查 👥 作者信息 N1netyNine99 - 嵌入式系统开发者\n📄 许可证 MIT License - 可自由用于个人和商业项目。\n💡 提示: 在使用前请仔细阅读GD25Q40E的数据手册，确保理解各项时序要求和电气特性。\n","date":"2025-08-21T00:00:00Z","image":"https://example.com/p/gd25q40e/pic2_hu_ce8e728c2d5e5b2d.jpg","permalink":"https://example.com/p/gd25q40e/","title":"GD25Q40E驱动"},{"content":"HWT101 陀螺仪模块移植指南 源码下载 HWT101.c HWT101.h 概述 本项目实现了对HWT101陀螺仪模块的驱动，支持获取偏航角度和角速度数据。HWT101是一款高精度的九轴姿态传感器，通过UART通信接口与MCU进行数据交换。\n硬件配置要求 1. UART配置 使用的UART: USART2 (huart2) 波特率: 115200 数据位: 8位 停止位: 1位 校验位: 无 流控: 无 模式: 发送+接收 2. DMA配置 需要为USART2配置DMA接收，以支持空闲中断接收：\nDMA通道: DMA1_Stream5 (USART2_RX) 传输方向: 外设到内存 模式: 普通模式 数据宽度: 字节 3. 引脚连接 请根据你的开发板配置USART2的引脚：\nTX引脚: 通常为PA2 RX引脚: 通常为PA3 VCC: 3.3V或5V (根据模块规格) GND: 接地 软件移植步骤 1. 复制必要的文件 将以下文件复制到你的项目中：\n1 2 BSP/Inc/HWT101.h # HWT101头文件 BSP/Src/HWT101.c # HWT101源文件 2. 头文件包含 在你的项目配置文件中包含HWT101.h：\n1 #include \u0026#34;HWT101.h\u0026#34; 3. UART配置修改 如果你使用的不是USART2，需要修改HWT101.h中的宏定义：\n1 #define HWT101_UART \u0026amp;huart2 // 改为你使用的UART句柄 4. 中断处理函数 在你的中断处理文件中添加UART空闲中断处理：\n1 2 3 4 5 6 7 8 void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size) { if (huart == HWT101_UART) { HWT101_Handler(Size); } // 其他UART处理... } 5. 初始化和使用 初始化 1 2 3 4 5 void Task_Init(void) { // 其他初始化... HWT101_Init(); // 初始化HWT101模块 } 数据读取 1 2 3 4 5 6 7 8 void Task_IdleFunction(void) { if (HWT_Ready_Flag == true) { HWT_Ready_Flag = false; HWT101_Read(); // 解析接收到的数据 } } 获取数据 1 2 3 4 5 // 全局变量，可直接使用 extern float HWT_Yaw_Angle; // 偏航角度 (-180° ~ +180°) extern float HWT_Y_Speed; // Y轴角速度 (°/s) extern float HWT_Z_Speed; // Z轴角速度 (°/s) extern bool HWT_Ready_Flag; // 数据准备标志 模块特性 自动配置 模块初始化时会自动发送以下配置命令：\n关闭LED指示灯 解锁寄存器 Z轴角度归零 设置输出频率为500Hz 设置波特率为115200 保存配置并重启 数据解析 角度数据: 当接收到0x55 0x53开头的数据包时解析偏航角 角速度数据: 当接收到0x55 0x52开头的数据包时解析Y轴和Z轴角速度 校验和验证: 每个数据包都会进行校验和验证确保数据完整性 通信协议 数据包长度: 11字节 包头: 0x55 数据类型: 0x52(角速度) 或 0x53(角度) 校验方式: 累加校验 注意事项 DMA配置: 必须正确配置UART的DMA接收，否则无法正常接收数据 中断优先级: 确保UART中断优先级设置合理 初始化延时: 模块初始化时各命令间有延时，重启命令后需要500ms延时 数据更新: 数据以500Hz频率更新，建议在主循环中检查数据就绪标志 角度范围: 偏航角度范围为-180°到+180° 角速度范围: 角速度范围为±2000°/s 故障排除 无数据接收:\n检查UART配置和引脚连接 确认DMA配置正确 检查波特率设置 数据解析失败:\n检查校验和计算 确认数据包格式 验证通信时序 数据不稳定:\n检查电源供电 确认模块安装牢固 检查干扰源 示例代码 完整的使用示例请参考项目中的Task_App.c文件，其中展示了如何在OLED显示屏上显示陀螺仪数据。\n版本信息 支持的模块: HWT101 通信接口: UART 输出频率: 500Hz 数据精度: 16位 ","date":"2025-08-21T00:00:00Z","image":"https://example.com/p/hwt101/HWT101_hu_6505026b8649403e.jpg","permalink":"https://example.com/p/hwt101/","title":"HWT101 驱动"},{"content":"OLED 0.96寸 DMA驱动库使用说明 (IIC \u0026amp; SPI 版本) 源码下载 SPI版本 注意:SPI版本目前还有问题，在显示大型图片会不稳定\nOLED.c OLED.h OLED_Font.h IIC版本 OLED.c OLED.h OLED_Font.h 📖 概述 本驱动库基于STM32 HAL库开发，专为0.96寸OLED显示屏设计，支持I2C和SPI两种通信方式，均采用DMA方案实现高性能显示。支持SSD1306控制器，分辨率128x64像素。两个版本的API接口完全相同，便于切换使用。\n✨ 特性 🚀 高性能: 基于DMA非阻塞传输，显示效率高 🎨 丰富的图形功能: 支持点、线、矩形、圆形、三角形等几何图形 📝 灵活的文本显示: 支持6x8和8x16两种字体，支持Printf格式化输出 🔧 易于集成: 简单的API接口，易于移植 💾 双缓冲机制: 使用显示缓冲区，避免显示闪烁 🔄 双模式支持: IIC和SPI版本无缝切换，共享相同API 🛠️ 硬件配置要求 IIC配置 I2C外设: I2C1 (可在OLED.h中修改OLED_I2C宏定义) I2C地址: 0x78 (可在OLED.h中修改OLED_ADDR宏定义) 时钟频率: 建议100kHz-400kHz CubeMX配置步骤 (IIC) 启用I2C1\nMode: I2C Configuration: Fast Mode (400kHz) 启用DMA\n在DMA Settings中添加I2C1_TX通道 Direction: Memory To Peripheral Priority: Medium或High 启用中断\nI2C1 event interrupt: ✅ 启用 I2C1 error interrupt: ✅ 启用 DMA1 Channel X global interrupt: ✅ 启用 引脚配置\n1 2 PB6 -\u0026gt; I2C1_SCL PB7 -\u0026gt; I2C1_SDA (具体引脚根据你的硬件设计调整)\nSPI配置 SPI外设: SPI1 (可在OLED.h中修改OLED_SPI宏定义) DC/RES/CS引脚: 用于命令/数据切换和重置还有片选 (可在OLED.h中修改相关宏定义) CubeMX配置步骤 (SPI) 启用SPI1\nMode: Full-Duplex Master 或者 Transmit Master Only(推荐) 软件片选 Configuration:默认即可 SPI最稳定在 10M bits/s 最高在20M bits/s 左右 启用DMA\n在DMA Settings中添加SPI1_TX通道 Direction: Memory To Peripheral Priority: Medium或High 启用中断\nSPI1 global interrupt: ✅ 启用 DMA1 Channel X global interrupt: ✅ 启用 引脚配置\n1 2 3 4 PA5 -\u0026gt; SPI1_SCK PA7 -\u0026gt; SPI1_MOSI PB0 -\u0026gt; OLED_DC (命令/数据切换，高电平=数据，低电平=命令) PB1 -\u0026gt; OLED_RES (重置，低电平=重置) (具体引脚根据你的硬件设计调整)\n📁 文件结构 1 2 3 4 5 OLED/ ├── OLED.h # 头文件，包含所有函数声明和宏定义 (IIC/SPI通用，根据宏配置) ├── OLED.c # 主实现文件 (根据通信方式选择对应版本的实现) ├── OLED_Font.h # 字体数据文件 (通用) └── readme.md # 本说明文档 注意: 根据选择的通信方式，使用对应的OLED.c实现文件。头文件OLED.h中通过宏定义（如OLED_SPI或OLED_I2C）区分配置。\n🚀 快速开始 1. 添加文件到工程 将所有源文件添加到你的STM32项目中，并在主文件中包含头文件。根据通信方式在OLED.h中配置宏定义（如定义OLED_SPI或OLED_I2C），并把对应中断回调函数（如OLED_I2C_MasterTxCplt_Handler或OLED_SPI_TxCplt_Handler）放到HAL回调中。\n1 #include \u0026#34;OLED.h\u0026#34; 2. 初始化OLED 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 int main(void) { HAL_Init(); SystemClock_Config(); MX_GPIO_Init(); // 根据模式初始化外设 // IIC模式: MX_I2C1_Init(); // SPI模式: // MX_SPI1_Init(); MX_DMA_Init(); // 初始化OLED OLED_Init(); while(1) { // 你的主循环代码 } } 3. 基本显示示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 清屏 OLED_Clear(); // 显示字符串 OLED_ShowString(0, 0, \u0026#34;Hello OLED!\u0026#34;, 16); // 显示数字 OLED_ShowNum(0, 2, 12345, 5, 16); // 使用Printf格式化显示 OLED_Printf(0, 4, 16, \u0026#34;Temp: %d°C\u0026#34;, 25); // 更新显示（必须调用此函数才能在屏幕上看到内容） OLED_Update(); 📚 API参考 基础控制函数 void OLED_Init(void) 初始化OLED显示屏，必须在使用其他函数前调用。\nvoid OLED_Clear(void) 清空显示缓冲区，将所有像素设为黑色。\nvoid OLED_Update(void) 将显示缓冲区内容更新到OLED屏幕，使用DMA高速传输。\nvoid OLED_Display_On(void) / void OLED_Display_Off(void) 开启/关闭OLED显示。\nvoid OLED_fill_picture(uint8_t fill_Data) 用指定数据填充整个显示缓冲区。\nfill_Data: 填充数据 (0x00=全黑, 0xFF=全白) 文本显示函数 void OLED_ShowChar(uint8_t x, uint8_t y, uint8_t Char_Size, uint8_t chr) 在指定位置显示单个字符。\nx: 列坐标 (0-127) y: 页坐标 (0-7) chr: 要显示的字符 Char_Size: 字符大小 (12: 6x8字体, 16: 8x16字体) void OLED_ShowString(uint8_t x, uint8_t y, uint8_t Char_Size, uint8_t *p) 显示字符串。\np: 字符串指针 void OLED_ShowNum(uint8_t x, uint8_t y, uint8_t Char_Size, uint32_t num, uint8_t len) 显示数字。\nnum: 要显示的数字 len: 数字长度 Char_Size: 字符大小 void OLED_Printf(uint8_t x, uint8_t y, uint8_t Char_Size, const char *format, ...) Printf风格的格式化显示。\nformat: 格式化字符串 ...: 可变参数 图形绘制函数 基础图形 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 画像素点 void OLED_DrawPixel(uint8_t x, uint8_t y, uint8_t color); // 画直线 void OLED_DrawLine(uint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2, uint8_t color); // 画矩形边框 void OLED_DrawRect(uint8_t x, uint8_t y, uint8_t width, uint8_t height, uint8_t color); // 填充矩形 void OLED_FillRect(uint8_t x, uint8_t y, uint8_t width, uint8_t height, uint8_t color); // 画圆形边框 void OLED_DrawCircle(uint8_t x0, uint8_t y0, uint8_t radius, uint8_t color); // 填充圆形 void OLED_FillCircle(uint8_t x0, uint8_t y0, uint8_t radius, uint8_t color); 高级图形 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 画三角形 void OLED_DrawTriangle(uint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2, uint8_t x3, uint8_t y3, uint8_t color); // 填充三角形 void OLED_FillTriangle(uint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2, uint8_t x3, uint8_t y3, uint8_t color); // 画椭圆 void OLED_DrawEllipse(uint8_t x0, uint8_t y0, uint8_t rx, uint8_t ry, uint8_t color); // 画圆角矩形 void OLED_DrawRoundRect(uint8_t x, uint8_t y, uint8_t width, uint8_t height, uint8_t radius, uint8_t color); // 画箭头 void OLED_DrawArrow(uint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2, uint8_t size, uint8_t color); 实用功能 1 2 3 4 5 6 7 8 9 10 11 // 画网格 void OLED_DrawGrid(uint8_t spacing, uint8_t color); // 画进度条 void OLED_DrawProgressBar(uint8_t x, uint8_t y, uint8_t width, uint8_t height, uint8_t progress, uint8_t color); // 画带厚度的边框 void OLED_DrawFrame(uint8_t x, uint8_t y, uint8_t width, uint8_t height, uint8_t thickness, uint8_t color); // 显示位图 void OLED_DrawBitmap(uint8_t x, uint8_t y, const uint8_t *bitmap, uint8_t width, uint8_t height, uint8_t color); 坐标系统说明 列坐标 (x): 0-127，从左到右 行坐标 (y): 0-63，从上到下 (像素坐标) 页坐标 (y): 0-7，从上到下 (字符显示坐标，每页8个像素) 颜色参数: 0=黑色(像素熄灭), 1=白色(像素点亮) 🎯 使用示例 示例1: 基本文本显示 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void DisplayBasicText(void) { OLED_Clear(); // 显示标题 (8x16字体) OLED_ShowString(0, 0, \u0026#34;STM32 OLED\u0026#34;, 16); // 显示系统信息 (6x8字体) OLED_ShowString(0, 2, \u0026#34;System: Running\u0026#34;, 12); OLED_ShowString(0, 3, \u0026#34;Voltage: 3.3V\u0026#34;, 12); // 显示实时数据 static uint16_t counter = 0; OLED_Printf(0, 5, 12, \u0026#34;Count: %d\u0026#34;, counter++); OLED_Update(); } 示例2: 图形界面 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void DisplayGraphicsDemo(void) { OLED_Clear(); // 画边框 OLED_DrawRect(0, 0, 128, 64, 1); // 画进度条 static uint8_t progress = 0; OLED_DrawProgressBar(10, 10, 100, 8, progress, 1); OLED_Printf(10, 20, 12, \u0026#34;Progress: %d%%\u0026#34;, progress); // 画一些装饰图形 OLED_DrawCircle(100, 40, 10, 1); OLED_FillCircle(30, 40, 5, 1); OLED_DrawTriangle(50, 35, 60, 35, 55, 45, 1); progress = (progress + 1) % 101; OLED_Update(); } 示例3: 数据监控界面 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 typedef struct { float temperature; float humidity; uint16_t battery_mv; } SensorData_t; void DisplaySensorData(SensorData_t* data) { OLED_Clear(); // 标题 OLED_ShowString(35, 0, \u0026#34;Sensor Data\u0026#34;, 12); OLED_DrawLine(0, 10, 127, 10, 1); // 温度 OLED_Printf(5, 15, 12, \u0026#34;Temp: %.1f C\u0026#34;, data-\u0026gt;temperature); // 湿度 OLED_Printf(5, 25, 12, \u0026#34;Humi: %.1f%%\u0026#34;, data-\u0026gt;humidity); // 电池电压 OLED_Printf(5, 35, 12, \u0026#34;Batt: %dmV\u0026#34;, data-\u0026gt;battery_mv); // 电池电量条 uint8_t battery_percent = (data-\u0026gt;battery_mv - 3000) * 100 / 1200; // 3.0V-4.2V OLED_DrawProgressBar(5, 45, 80, 6, battery_percent, 1); // 状态指示器 OLED_FillCircle(100, 48, 3, 1); OLED_ShowString(105, 47, \u0026#34;OK\u0026#34;, 12); OLED_Update(); } ⚠️ 注意事项 必须调用OLED_Update()\n所有绘制操作都是在显示缓冲区中进行 必须调用OLED_Update()才能将内容显示到屏幕上 DMA传输状态\nOLED_Update()使用DMA非阻塞传输 如果上一次传输未完成，会跳过本次更新 正常情况下刷新频率可达到数十Hz 中断回调函数\n确保在stm32xxxx_it.c中正确实现I2C/SPI和DMA中断回调 本库已提供回调函数实现，会自动处理DMA传输 (IIC: OLED_I2C_xxx_Handler; SPI: OLED_SPI_xxx_Handler) 坐标边界\n绘制时注意坐标边界，超出范围的绘制会被忽略 文本显示会自动换行处理 性能优化建议\n避免频繁调用OLED_Clear() 批量绘制后再调用OLED_Update() 对于动画效果，建议控制刷新频率 模式切换\n在OLED.h中通过宏定义选择IIC或SPI模式 SPI版本额外需要DC和RES引脚控制 🔧 故障排除 显示屏无反应 检查通信连接 (IIC: SCL/SDA; SPI: SCK/MOSI/DC/RES) 确认CubeMX配置中的DMA和中断设置 验证电源供电 (3.3V/5V) 显示内容不更新 确保调用了OLED_Update() 检查DMA传输是否正常工作 验证中断是否正确响应 (IIC/SPI特定) 显示异常/乱码 检查字体文件是否正确包含 确认坐标参数是否在有效范围内 验证字符编码是否匹配 📝 版本历史 v1.0 (2025-07-28) 初始版本发布，支持IIC和SPI双模式 支持基本文本和图形显示 实现DMA高速传输 👨‍💻 作者信息 作者: N1ntyNine99 基于: CSDN博客文章 和 另一个CSDN文章 日期: 2025-07-28 📄 许可证 本项目采用开源许可证，请根据需要使用和修改。\n💡 提示: 如有任何问题或建议，欢迎通过Issues反馈！\n","date":"2025-08-21T00:00:00Z","image":"https://example.com/p/oled/OLED_hu_56ad3a7303b2bb59.jpg","permalink":"https://example.com/p/oled/","title":"OLED DMA高刷驱动"},{"content":"[TOC]\nChapter 1: Cargo——Rust 的包管理器 Cargo 是 Rust 的一个强大的包管理器，通过 cargo 可以快速构建一个结构完整的 Rust 项目，并且通过命令行来编译运行项目\n1.cargo new **该指令用于创建一个完整的 Rust 项目 可加参数“vsc ==”来创建附加内容，默认创建了一个 git 存储库，但是我关掉了，具体关掉的方法如下: **\n在 Rust 中使用 cargo 创建新项目时，默认会初始化一个 Git 仓库。如果你希望 不自动添加 Git 版本控制，可以使用以下两种方法：\n方法 1：使用 --vcs none 参数 在创建项目时，显式指定不初始化任何版本控制系统：\nbash\n1 cargo new --vcs none my_project 这会跳过 Git 仓库的初始化。\n方法 2：全局配置 Cargo 默认不初始化 Git 如果你希望所有新项目都默认不初始化 Git，可以修改 Cargo 的全局配置：\n打开或创建 Cargo 的配置文件 ~/.cargo/config.toml（Linux/macOS）或 %USERPROFILE%\\.cargo\\config.toml（Windows）。\n添加以下内容：\ntoml\n1 2 [cargo-new] vcs = \u0026#34;none\u0026#34; 这样之后所有 cargo new 命令都会跳过版本控制系统的初始化。\n补充说明 如果已经创建了项目，你可以直接删除项目根目录下的 .git 文件夹来移除 Git 跟踪。 支持的 --vcs 选项包括：git（默认）、hg（Mercurial）、pijul 或 none。 这种方法既简单又干净，适合不需要版本控制或打算使用其他版本控制系统（如 Mercurial 或 SVN）的情况。\n2.cargo build 该指令用于编译并生成一个可执行的二进制文件 注意与后文的 cargo check 区分。可以添加 --release 来让生成文件存放在 targer/release 中，而非默认的 target/debug 中。\n3.cargo check 该指令用来编译当前的工程，但注意, cargo check 并不会和 cargo build 一样生成一个可执行的二进制文件，所以耗时会大大快于后者，通常用于代码工程编写中途来检测当前有无显著语法错误。\n4.cargo run 编译并且运行。\nChapter 2: 猜数游戏 程序将生成一个介于 1 到 100 之间的随机整数。然后它会提示玩家输入猜测。输入猜测后，程序会指示猜测是太低还是太高。如果猜对，游戏将打印一条祝贺消息并退出。\n2.1 使用标准输入输出流 想要实现一个猜数游戏，首先能够进行标准的输入输出，所以就要引入 Rust 官方的标准输入输出流 use std::io;。其作用类似于 C 语言中的 #include \u0026lt;stdio.h\u0026gt;，其中“std”表示“standard library”，即标准库的意思，而“io”就是输入输出模块的意思。\n正常情况下，Rust 的标准库中存在很多模块，称之为 prelude，具体的所有内容可以通过 [Rust 标准库](Hello, Cargo! - The Rust Programming Language \u0026ldquo;Rust 标准库\u0026rdquo;)中查看。\n2.2.fn main() 在 Rust 中，关键字 fn 表示声明一个函数，() 中填入函数的入参，和 C 语言一样，Rust 总是从 main 函数中作为入口进入。\n2.3.println!() 作为一个输出语句，Rust 标准的输出语句是 println，没有 !, 这个感叹号的意思是这是一个 “宏(marco)”，而非一个函数。而 println! 的标准占位符是 {}，具体用法后文再提。\n2.4.let 在 Rust 中，let 用来声明一个变量，比如 let apple = 5; 在这个语句中，我们声明了一个变量名为 apple，其值为 5 的一个变量。在 Rust 中，如果不做说明，则默认声明的变量是一个 “不可变的(immutable)”。意思就是，在我们声明了这个 apple 之后，是没有办法修改其值 5 的，编译器会报错，如下图所示：\n我们现在删除修改其值的语句之后再次编译会发现就可以成功通过编译并且运行: 如果所有的变量都是不可变的，那 Rust 也太鸡肋了，所以官方有一个关键字 mut，来声明这个变量是 “可变的(mutable)”，在声明变量的时候加上这个关键字就可以告知编译器，当前这个变量是一个可变的变量。如下图所示: 2.5.String:: new() 1 2 3 4 5 6 7 8 9 use std::io; //意思是使用标准输入输出流 类似于C中的 #include \u0026lt;stdio.h\u0026gt; fn main() { println!(\u0026#34;Guess a Number Please!\u0026#34;); //Rust的println!会自带一个回车 let mut guess = String::new(); //创建了一个字符串类型的变量，mut表示可变 new()表示创建了一个String的实例 io::stdin().read_line(\u0026amp;mut guess).expect(\u0026#34;Fail to readline\u0026#34;); println!(\u0026#34;You guessed:{guess}\u0026#34;); } let mut guess = String::new(); 创建了一个字符串类型的变量，其中 mut 表示可变，new()表示创建了一个 String 的实例。在 Rust 中，:: 表示一个与前者关联的一个函数，在这里，String 是 Rust 标准库提供的一个字符串数据类型，new() 表示创建一个新的实例，是 String 所提供的一个“关联函数(associated function)”，所谓关联函数，是一个类中的函数，可以理解为 Python 中一个“类（class）”中的一个“方法（method）”。\n2.6 读取用户输入 io::stdin().read_line(\u0026amp;mut guess).expect(\u0026quot;Fail to readline\u0026quot;); 这条语句用来读取用户的终端输入。由于我们在第一行就显式的引入了标准输入输出，我们这里可以直接使用 io::stdin() 来使用 stdin() 这个方法。如果我们没有在第一行中显式的导入标准输入输出，我们同样可以直接调用 stdin() 但是需要说明来源，如 stdio::io::stdin。\n在 io::stdin() 中，stdin() 会返回一个 std::io::Stdin 的一个实例，该类型是作为一个获取用户终端输入的一个“句柄（handle）”。\n之后的 .read_line(\u0026amp;mut guess) 调用了 read_line 方法来获取用户的输入，并且传入了 \u0026amp;mut guess 来告诉 Rust 将读到的字符串放到 guess 变量中。read_line 会将用户在终端中输入的所有内容都变换成一个字符串来存储，存储方式是“追加（append）”，而不是“覆写（overwrite）”。\n代码中的 \u0026amp;，表示是“引用（reference）”，提供了一种让代码的多个部分都可以访问这一条数据，并且不需要多次复制这条数据的方法。本章中不做深究，在后续的章节中会详细讲解 Rust 的 \u0026amp;。目前我们只需要知道引用默认是不可变的，所以我们需要传入 \u0026amp;mut guess 作为参数而不是直接传入 \u0026amp;guess。\n2.7 处理潜在的问题 可以注意到，在读取输入的过程中我们还有一句话，是 .expect(\u0026quot;Fail to readline\u0026quot;)。本小节我们将着重讨论这个语句。\n如前文所提到的，read_line 方法会将用户的任何输入都读取到一个字符串中，但是它也会返回一个 Result 来表明语句的执行情况。这个 Result 是一个“枚举值（enumeration）（也简写为 enum）”。用于进行错误处理的。详细内容将在后面仔细讲解如何通过这个值来在 Rust 中对代码进行错误处理。\nResult 的值有两种，分别是 Err 和 Ok，前者表示语句执行出现错误，并且会包含一些调试信息，后者表示顺利执行。而 except 是 Result 类型的一种方法，如果 Result 的返回值为 Err，那么 except 就会终止程序，并且在终端中显示我们传入进去的字符串。如果 Result 的返回值是 Ok，在本条语句中，返回值将是用户输入的字节数目。如果不添加 except，项目依旧可以正常编译，但是编译器会向我们发送警告：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 $ cargo build Compiling guessing_game v0.1.0 (file:///projects/guessing_game) warning: unused `Result` that must be used --\u0026gt; src/main.rs:10:5 | 10 | io::stdin().read_line(\u0026amp;mut guess); | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ | = note: this `Result` may be an `Err` variant, which should be handled = note: `#[warn(unused_must_use)]` on by default help: use `let _ = ...` to ignore the resulting value | 10 | let _ = io::stdin().read_line(\u0026amp;mut guess); | +++++++ warning: `guessing_game` (bin \u0026#34;guessing_game\u0026#34;) generated 1 warning Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.59s 2.8 导入外部 crate 在使用 rand 生成随机数之前，我们首先需要修改 Cargo.toml，把 rand 添加到我们的“依赖（dependencies）”中：\n其中格式为“crate 名 + 版本号”（Rust 中的 crates 可以简单理解为外部库），这里的 0.8.5 是 ^0.8.5 的简写，意味着任何低于 0.9 但是高于等于 0.8.5 的版本。\n接下来不对代码做任何修改，直接编译运行，我们会发现，它在自己下载相关依赖并且重新编译： 当我们包含外部依赖项时，Cargo 会从 注册表 中获取依赖项所需的所有内容的最新版本， 注册表 是 Crates.io 中的数据副本。Crates.io 是 Rust 生态系统中的人们发布他们的开源 Rust 项目供其他人使用的地方。\nCargo 拥有一种机制，确保每次你或其他人构建代码时都能重新构建相同的工件：Cargo 将仅使用你指定的依赖版本，直到你明确表示更改。例如，假设下周 rand crate 发布了 0.8.6 版本，该版本包含一个重要的错误修复，但也包含一个会导致你的代码出错的回归问题。为了处理这种情况，Rust 在你第一次运行 cargo build 时会创建 Cargo.lock 文件，因此现在我们在 guessing_game 目录中有了这个文件。\n当你第一次构建项目时，Cargo 会确定所有符合要求的依赖版本，并将这些版本写入 Cargo.lock 文件中。以后当你再次构建项目时，Cargo 会看到 Cargo.lock 文件存在，并使用该文件中指定的版本，而不是重新计算版本。这使得你可以自动获得可重复的构建结果。换句话说，由于 Cargo.lock 文件的存在，你的项目会一直保持在 0.8.5 版本，直到你显式地进行升级。因为 Cargo.lock 文件对于可重复构建非常重要，所以它通常会和其他代码一起被纳入源代码控制中。\n当你需要更新一个 crates 时，Cargo 提供了 update 命令，该命令会忽略 Cargo.lock 文件，并找出所有符合 Cargo.toml 中你指定条件的最新版本。然后 Cargo 会将这些版本写入 Cargo.lock 文件。在这种情况下，Cargo 将只查找版本号大于 0.8.5 且小于 0.9.0 的版本。如果 rand crates 发布了两个新版本 0.8.6 和 0.9.0，当你运行 cargo update 时，你会看到以下内容:\n1 2 3 4 $ cargo update Updating crates.io index Locking 1 package to latest Rust 1.85.0 compatible version Updating rand v0.8.5 -\u0026gt; v0.8.6 (available: v0.9.0) 2.9 生成随机数 1 2 3 4 5 6 7 8 9 10 11 use rand::Rng; //添加了rand库中的Rng模块 use std::io; fn main() { let mut guess = String::new(); let secret_number = rand::thread_rng().gen_range(1..=100); //生成一个1~100的随机数 println!(\u0026#34;The secre number is {secret_number}\u0026#34;); println!(\u0026#34;Guess a Number Please!\u0026#34;); io::stdin().read_line(\u0026amp;mut guess).expect(\u0026#34;Fail to readline\u0026#34;); println!(\u0026#34;You guessed:{guess}\u0026#34;); } 如上更新了代码，我们先是引用了 rand 库的 Rng 模块，里面定义了生成随机数的方法，之后使用不可变的变量获得了一个 1~100 的随机数。rand::thread_rng 是一个仅限于当前执行线程且由操作系统初始化的生成器，加上后文的 gen_range 就可以产生一个随机数，其中 gen_range 的入参是一个范围表达式，用来指定生成随机数的范围。\n[!TIP]\n你无法凭空知道该使用哪些特性（traits）、调用哪些方法和函数，因此每个 crate（Rust 库）都附带了说明文档。Cargo 还有一个便捷功能：运行 cargo doc --open 命令会在本地构建所有依赖项的文档，并在浏览器中打开。例如，如果你想了解 rand crate 的其他功能，只需运行 cargo doc --open，然后在左侧边栏点击 rand 即可查看其文档。\n2.10 match——通过分支结构来比较随机数与猜测数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 use rand::Rng; use std::cmp::Ordering; use std::io; //引入cmp库 fn main() { let mut guess = String::new(); let secret_number = rand::thread_rng().gen_range(1..=100); //生成1~100的随机数 println!(\u0026#34;Plz guess a int from 1 to 100\u0026#34;); io::stdin().read_line(\u0026amp;mut guess).expect(\u0026#34;Can`t read line\u0026#34;); //读取猜测数 match guess.cmp(\u0026amp;secret_number) { //比较、并且输出对应调试信息 Ordering::Equal =\u0026gt; println!(\u0026#34;u got right answer{secret_number}\u0026#34;), Ordering::Greater =\u0026gt; println!(\u0026#34;guess {guess} is bigger than secret number {secret_number}\u0026#34;), Ordering::Less =\u0026gt; println!(\u0026#34;guess {guess} is less than secret number {secret_number}\u0026#34;), } } 首先我们先导入 cmp 库中的 Ordering 模块，Ordering 本质也是一个枚举，拥有 Equal, Greater, Less 三个值。match 在这里的作用是根据后面的 Ordering 的值来匹配执行不同的语句，类似与 C 语言中的 switch case 语句，它是顺序依次匹配。而不同的返回值对应的执行语句则是通过 =\u0026gt; 来引出。我们通过 .cmp 方法来比较 guess 和 secret_number 的值, 并且返回对应的 Ordering 的枚举值。注意，.cmp 中应当使用 \u0026amp; 来引用，而不是直接通过传入变量名来比较！\n接下来我们编译运行，会发现运行报错： 报错的主要问题是“类型不匹配（mismatch）”。Rust 作为一个强静态类型语言，具有一个数据类型推测功能。我们的 guess，在最开始声明的时候就是 String 字符串类型，但是我们生成的随机数，由于我们没有显式的指定类型，编译器会自己猜测数据类型，通常会猜测是一个“整型（integer）”，Rust 的几种数值类型中，有些可以在 1 到 100 之间取值： i32 （32 位数值）、 u32 （无符号 32 位数值）、 i64 （64 位数值），以及其他类型。除非另有指定，Rust 默认使用 i32 类型。我们想要把一个字符串与整型比较，这显然是不符合常理的，所以编译器才会报错，说 expected \u0026amp;String, found \u0026amp;{integer}, 预期输入的是一个字符串，但是却发现输入的是一个整型。\n想要能够正确识别，我们可以将 guess 从字符串转换为整型。代码如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 use rand::Rng; use std::cmp::Ordering; use std::io; fn main() { let mut guess = String::new(); let secret_number = rand::thread_rng().gen_range(1..=100); println!(\u0026#34;Plz guess a int from 1 to 100\u0026#34;); io::stdin().read_line(\u0026amp;mut guess).expect(\u0026#34;Can`t read line\u0026#34;); let guess: u32 = guess .trim() .parse() .expect(\u0026#34;Please type a number rather than ohter types!\u0026#34;); //类型转换 match guess.cmp(\u0026amp;secret_number) { //比较、并且输出对应调试信息 Ordering::Equal =\u0026gt; println!(\u0026#34;u got right answer{secret_number}\u0026#34;), Ordering::Greater =\u0026gt; println!(\u0026#34;guess {guess} is bigger than secret number {secret_number}\u0026#34;), Ordering::Less =\u0026gt; println!(\u0026#34;guess {guess} is less than secret number {secret_number}\u0026#34;), } } 我们会惊奇的发现，明明 guess 这个变量在之前定义过了，这里怎么还可以再次定义，而且编译器还没有报错？！这是因为 Rust 中允许重复使用一个变量名，但是之后的变量会覆盖前面的变量值。在这里，我们后面的 guess 就成功用整型的数值覆盖了之前的 guess 的字符串类型的数值。这种特性可以让我们重复的使用一个变量名，而不是使用 guess_str 和 guess_int 来区分。眼下我们只需要知道，我们进行数据类型变换的时候通常会使用这个特性。\n我们现在来看看我们的转换语，首先 guess.trim() 中的 guess，是最先开始的那个字符串，而其调用了 trim() 方法，该方法的作用是消除开头和结尾的任何空白，这是在将字符串转换为只能包含数值数据的 u32 之前必须做的。用户必须按下 enter 来触发 read_line 并输入他们的猜测，这会在字符串中添加一个换行符。例如，如果用户输入 5 并按下 enter ， guess 看起来是这样的： 5\\n 。 \\n 代表“换行”（在 Windows 上，按下 enter 会导致回车和换行， \\r\\n ）。 trim 方法会消除 \\n 或 \\r\\n ，结果只剩下 5 。\n接下里的 parse() 则是把字符串类型转换成别的数类型。使用的时候我们必须显式的告诉编译器我们期望转换的类型，通过赋值语句之前的 :u32 来告诉编译器我们想要的数据类型是一个无符号 32 位整型。同时这也意味着编译器会推断 secret_number 也是一个 u32 的数据类型，以此才方便两者比较。最后再加上 except() 来进行可能的错误处理。\n[!NOTE]\nparse 方法只适用于逻辑上可以转换为数字的字符，因此很容易导致错误。例如，如果字符串包含 A👍% ，则无法将其转换为数字。由于它可能会失败， parse 方法返回 Result 类型，就像 read_line 方法一样。我们将以相同的方式处理这个 Result ，再次使用 expect 方法。如果 parse 因为无法从字符串中创建数字而返回 Err ， expect 调用将崩溃游戏并打印我们给它的消息。如果 parse 成功将字符串转换为数字，它将返回 Ok 变体的 Result ，而 expect 将返回我们从 Ok 值中想要的数字。\n接下来我们直接编译并且运行代码，会发现代码成功运行起来了：\n但是有个显而易见的问题，不论我们猜测的正确与否，我们都只能猜测依次，我们预期的是，我们不停猜测，直到我们猜测的结果正确为止，这就涉及到了一个重要概念——“循环（loop）”！\n2.11 通过循环实现多次猜测 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 use rand::Rng; use std::cmp::Ordering; use std::io; fn main() { let secret_number = rand::thread_rng().gen_range(1..=100); println!(\u0026#34;Plz guess a int from 1 to 100\u0026#34;); loop { //Loop循环 死循环 需要手动退出 let mut guess = String::new(); io::stdin().read_line(\u0026amp;mut guess).expect(\u0026#34;Can`t read line\u0026#34;); let guess: u32 = guess .trim() .parse() .expect(\u0026#34;Please type a number rather than ohter types!\u0026#34;); match guess.cmp(\u0026amp;secret_number) { Ordering::Equal =\u0026gt; println!(\u0026#34;u got right answer{secret_number}\u0026#34;), Ordering::Greater =\u0026gt;println!(\u0026#34;guess {guess} is bigger than secret number {secret_number}\u0026#34;), Ordering::Less =\u0026gt; println!(\u0026#34;guess {guess} is less than secret number {secret_number}\u0026#34;), } } } 现在我们可以多次循环猜测，但是也出现了一个问题：没有终止体条件！！所以我们要添加一个终止条件，即如果我们猜测的数刚好就是产生的数，则自动停止。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 use rand::Rng; use std::cmp::Ordering; use std::io; fn main() { let secret_number = rand::thread_rng().gen_range(1..=100); println!(\u0026#34;Plz guess a int from 1 to 100\u0026#34;); loop { //Loop循环 let mut guess = String::new(); io::stdin().read_line(\u0026amp;mut guess).expect(\u0026#34;Can`t read line\u0026#34;); let guess: u32 = guess .trim() .parse() .expect(\u0026#34;Please type a number rather than ohter types!\u0026#34;); match guess.cmp(\u0026amp;secret_number) { Ordering::Greater =\u0026gt; { println!(\u0026#34;{guess} is too big\u0026#34;) } Ordering::Less =\u0026gt; println!(\u0026#34;{guess} is too small\u0026#34;), Ordering::Equal =\u0026gt; { println!(\u0026#34;you got right answer:{secret_number}\u0026#34;); break; } //使用一个代码块来将一条分支对应所要执行的代码都括起来 } } } 现在看来当前的内容完整了，但是我们对于非数字的处理只是简单暴力的终止程序，并不是一个可取的操作，我们应该想要的是跳过本次循环，向终端中发送提示，然后下一个循环继续——continue。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 use core::num; use rand::Rng; use std::cmp::Ordering; use std::io; fn main() { let secret_number = rand::thread_rng().gen_range(1..=100); println!(\u0026#34;Plz guess a int from 1 to 100\u0026#34;); loop { let mut guess = String::new(); io::stdin().read_line(\u0026amp;mut guess).expect(\u0026#34;Can`t read line\u0026#34;); let guess: u32 = match guess.trim().parse() { Ok(num) =\u0026gt; num,//如果是Ok的话(num)会让num自动等于转换完成的值 Err(_) =\u0026gt; { println!(\u0026#34;Please input number between 1 and 100\u0026#34;);//Err的话()中是什么不重要 用_代替 表示捕获所有的错误值 continue; }//使用match分支来代替简单的except }; match guess.cmp(\u0026amp;secret_number) { Ordering::Greater =\u0026gt; { println!(\u0026#34;{guess} is too big\u0026#34;) } Ordering::Less =\u0026gt; println!(\u0026#34;{guess} is too small\u0026#34;), Ordering::Equal =\u0026gt; { println!(\u0026#34;you got right answer:{secret_number}\u0026#34;); break; } } } } 在这里，我们使用 match 分支来处理错误情况，上文提到过 Result 作为一个枚举值，有 OK 和 Err 两种情况。如果是 Ok 那么它会包含一个值，这个值就是我们预期想得到的一个类型转换后的值。如果是 Err，则 Err(_)。其中 _ 是一个 catch-all value，代表着不论这里存储的是什么，我们都期望与我们的这个分支匹配。\nChapter 3: 常见的编程概念 3.1 Rust 中特有概念 与其他编程语言不同，Rust 中有很多独有的概念，同时也是 Rust 的最重要的特性。\n3.1.1.变量(variable)和可变性（mutability） 正如之前所提到的，Rust 中的所有的变量默认是不可变的。如果我们想要让这个变量可变，需要使用到关键字 mut 来显式声明这个变量是可变的。\n3.1.2.常量(constants) 对于常量来说，我们是严令禁止 mut 声明的，因为常量本身的意义就在于不可变。声明一个常量我们使用的关键字是 const 而不是 let，并且常量必须显式的声明其数据类型，而不是和普通变量一样可以让编译器自己推测。\n3.1.3.变量遮蔽(shadowing) 在第二章中，我们使用了相同的变量名来处理数据类型变换的问题。在 Rust 中，我们通常说前一个变量被之后的变量给遮蔽了(shadowed by)，遮蔽的不仅是值，还有可变/不可变的属性。但是变量遮蔽仅仅存在于后来的变量的作用域中。\n1 2 3 4 5 6 7 8 9 10 fn main() { let x = 5; // 外部作用域 x = 5 let x = x + 2; // 遮蔽：x 重新绑定为 7（仍在外层作用域） println!(\u0026#34;x = {x}\u0026#34;); // 输出: x = 7 { let x = 9999; // 内部作用域的新变量 x，遮蔽外层的 x println!(\u0026#34;x = {x}\u0026#34;); // 输出: x = 9999 } // 内部 x 离开作用域，被丢弃 println!(\u0026#34;x = {x}\u0026#34;); // 恢复外部作用域的 x，输出: x = 7 } 1 2 3 4 结果: x`s value is 7 x`s value is 9999 x`s value is 7 在这个例子中，x 首先被声明为 5，紧接着就被 7（5 + 2）给遮蔽了，但是又在代码块中被 9999 给遮蔽，在 Rust 中，一个大括号对就代表一个代码块，其内部的变量的作用域只能作用域声明它的代码块中。所以当程序执行完第 7 行之后，值为 9999 的变量 x 会被销毁，所以第 9 行打印的 x 的值是之前的 x，即 7。\nmut 和遮蔽的另一个区别在于，当我们再次使用 let 关键字时，我们实际上是在创建一个新的变量，因此我们可以改变值的类型但重用相同的名称。例如，假设我们的程序要求用户输入一些空格字符来显示他们希望在文本之间有多少空格，然后我们想把输入存储为数字：\n1 2 let spaces = \u0026#34; \u0026#34;; let spaces = spaces.len(); 第一个 spaces 变量是字符串类型，第二个 spaces 变量是数字类型。因此，我们不必想出不同的名称，比如 spaces_str 和 spaces_num ；相反，我们可以重用更简单的 spaces 名称。然而，如果我们尝试像这样使用 mut ，我们会得到一个编译时错误：\n1 2 let mut spaces = \u0026#34; \u0026#34;; spaces = spaces.len(); 这是因为我们在第一行已经声明了 space 变量为一个字符串，而 len() 方法返回值是当前字符串的长度，是一个整数。我们尝试把一个整数赋值给一个字符串，这是 Rust 不允许的，所以报错了。正确做法应该是和上文一样使用两次 let。\n3.2 数据类型 Rust 作为一个静态类型语言，在编译的时候必须知道所有的数据的类型。一般来说，编译器可以通过我们给的赋值和使用来自己推断大多数的数据的类型。但是对于一些特殊情况，我们必须显式的声明数据类型，比如在声明一个常量的时候，比如在我们猜数游戏中的强制类型转换的时候。\n1 let guess: u32 = \u0026#34;42\u0026#34;.parse().expect(\u0026#34;Not a number!\u0026#34;); 如果我们不添加 :u32，那么编译器会报错如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 $ cargo build Compiling no_type_annotations v0.1.0 (file:///projects/no_type_annotations) error[E0284]: type annotations needed --\u0026gt; src/main.rs:2:9 | 2 | let guess = \u0026#34;42\u0026#34;.parse().expect(\u0026#34;Not a number!\u0026#34;); | ^^^^^ ----- type must be known at this point | = note: cannot satisfy `\u0026lt;_ as FromStr\u0026gt;::Err == _` help: consider giving `guess` an explicit type | 2 | let guess: /* Type */ = \u0026#34;42\u0026#34;.parse().expect(\u0026#34;Not a number!\u0026#34;); | ++++++++++++ For more information about this error, try `Rustc --explain E0284`. error: could not compile `no_type_annotations` (bin \u0026#34;no_type_annotations\u0026#34;) due to 1 previous error 3.2.1 标量 Rust 中的四种常见的标量分别是整数（integer）、浮点数（floating-point numbers）、布尔值（Booleans）和字符（characters）。\n3.2.2 整型 整型分为有符号整型 i 和无符号整型 u，具体内容如下表：\n长度 有符号 无符号 8-bits i8 u8 16-bit i16 u16 32-bit i32 u32 64-bit i64 u64 128-bit i128 u128 架构决定 isize usize 每个变体都可以是有符号或无符号的，并且具有明确的大小。有符号和无符号指的是该数字是否可能为负数——换句话说，该数字是否需要带有符号（有符号）或是否永远为正数，因此可以不需要符号来表示（无符号）。这就像在纸上写数字一样：当符号重要时，数字会显示加号或减号；然而，当可以安全地假设数字为正数时，则不显示符号。有符号数字使用二进制补码表示法存储。\n每个有符号变体可以存储从 −(2 ^n-1^ ) 到 2^n-1^-1 的数字，其中 n 是该变体使用的位数。因此一个 i8 可以存储从 −(2^7^ ) 到 2^7^ − 1 的数字，这等于 −128 到 127。无符号变体可以存储从 0 到 2^n^− 1 的数字，所以一个 u8 可以存储从 0 到 2^8^ − 1 的数字，这等于 0 到 255。\n此外， isize 和 usize 类型取决于你的程序运行在哪种计算机架构上：如果你在 64 位架构上，它们是 64 位的；如果你在 32 位架构上，它们是 32 位的。\n同时，你可以按照下表的所有方式书写整型。请注意，可以表示为多种数值类型的数字字面量允许使用类型后缀，例如 57u8 ，来指定类型。数字字面量也可以使用 _ 作为视觉分隔符，以便更容易阅读数字，例如 1_000 ，它将与你指定 1000 时具有相同的值。\n进制 例子 十进制 98_222 十六进制 0xff 八进制 0o77 二进制 0b1111_0000 字节 b’A’ [!NOTE]\n假设你有一个类型为 u8 的变量，它可以存储 0 到 255 之间的值。如果你尝试将变量更改为该范围之外的值，例如 256，就会发生整数溢出，这可能导致两种行为之一。在调试模式下编译时，Rust 会包含整数溢出的检查，如果发生这种行为，程序将在运行时崩溃。Rust 使用术语 panicking 来描述程序以错误退出。 当你以带 --release 标志的发布模式编译时，Rust 不会包含导致恐慌的整数溢出检查。相反，如果发生溢出，Rust 会执行补码回绕。简而言之，超出类型所能持有的最大值的值会“回绕”到类型所能持有的最小值。对于 u8 类型，值 256 会变成 0，值 257 会变成 1，以此类推。程序不会恐慌，但变量的值可能并不是你期望的值。依赖整数溢出的回绕行为被认为是一种错误。\n3.2.3 浮点数 Rust 中也有两种浮点数 f32，f64。分别代表双经度和单精度，分别占用 32 位和 64 位。默认类型是 f64 ，因为在现代 CPU 上，它的速度与 f32 大致相同，但能提供更高的精度。所有浮点数类型都是带符号的。\n1 2 3 4 fn main() { let x = 2.0; // f64 let y: f32 = 3.0; // f32 } 3.2.4 数值运算 1 2 3 4 5 6 7 8 9 10 11 12 13 fn main() { // 加法 let sum = 5 + 10;//15 // 减法 let difference = 95.5 - 4.3;//91.2 // 乘法 let product = 4 * 30;//120 // 除法 let quotient = 56.7 / 32.2;//1.7608695652173913 let truncated = -5 / 3; // -1 // 取余 let remainder = 43 % 5;//3 } [!CAUTION]\nlet value2 = 5.4 / -2; 这样的语句会报错，因为浮点数类型只能和浮点数类型相除。同样，浮点数不能取余。\n3.2.5 布尔值 和大多数其他编程语言一样，Rust 中的布尔类型有两个可能的值： true 和 false 。布尔类型的大小为 1 个字节。在 Rust 中，使用 bool 来指定布尔类型。例如：\n1 2 3 4 fn main() { let t = true; let f: bool = false; // 显式声明 } 3.2.6 字符类型 Rust 的 char 类型是语言中最原始的字母类型。这里有一些声明 char 值的例子：\n1 2 3 4 5 fn main() { let c = \u0026#39;z\u0026#39;; let z: char = \u0026#39;ℤ\u0026#39;; // 显式声明 let heart_eyed_cat = \u0026#39;😻\u0026#39;; } 请注意，我们使用单引号指定 char 字面量，而字符串字面量则使用双引号。Rust 的 char 类型占用四个字节，表示 Unicode 标量值，这意味着它不仅限于 ASCII 字符。带重音的字母；中、日、韩文字符；表情符号；以及零宽空格都是 Rust 中有效的 char 值。Unicode 标量值的范围从 U+0000 到 U+D7FF ，以及 U+E000 到 U+10FFFF 。然而，在 Unicode 中，“字符”并非一个真正存在的概念，因此你对“字符”的人类直觉可能与 Rust 中的 char 不一致。我们将在第 8 章的“使用字符串存储 UTF-8 编码文本”中详细讨论这一主题。\n3.2.6 复合类型 复合类型可以将多个值组合为一个类型。Rust 有两种原始复合类型：元组和数组。\n3.2.6.1 元组 Tuple 元组可以将不同类型的值存储在一个变量之中，但是一旦声明之后，就不能更改元组的长度。\n我们通过在括号内编写用逗号分隔的值列表来创建元组。元组中的每个位置都有一个类型，元组中不同值的类型不必相同。在这个示例中，我们添加了可选的类型注解：\n1 let tup: (i32, f64, u8) = (500, 6.4, 1); 变量 tup 绑定到整个元组，因为元组被视为一个复合元素。要从元组中获取各个值，我们可以使用模式匹配来解构元组值，如下所示：\n1 2 3 4 5 fn main() { let tup = (500, 6.4, 1); let (x, y, z) = tup; println!(\u0026#34;The value of y is: {y}\u0026#34;); } 上述代码首先创建了一个元组，并绑定在一个变量 tup 中，之后又使用 let 来让 (x,y,z) 分别获取 tup 对应位置的值。这个过程就叫“解构（destructuring）”。\n我们也可以通过 \u0026quot;.+索引值 \u0026quot; 来直接引用元组中的值，如下所示：\n1 2 3 4 5 6 fn main() { let x: (i32, f64, u8) = (500, 6.4, 1); let five_hundred = x.0;//500 let six_point_four = x.1;//6.4 let one = x.2;//1 } 这个程序创建了元组 x ，然后使用各自的索引访问元组的每个元素。和大多数编程语言一样，元组中的第一个索引是 0。但是，我们不能通过 . 配合一个变量来动态的访问一个元素：\n1 2 3 4 5 fn main() { let index: i32 = 0; let x: (i32, f64, u8) = (500, 6.4, 1); let five_hundred = x.index;//这是不允许的！ } 编译上面这段代码会如下报错: 这是因为如果是用一个变量动态的访问一个元组，很有可能，这个变量的面值超过了元组的元素数量，会造成类似数组越界的错误。这是 Rust 所不希望看见的。\n没有任何值的元组有一个特殊的名称，称为 unit。这个值及其对应类型都写作 () ，表示一个空值或一个空的返回类型。如果表达式没有返回其他值，则会隐式返回 unit 值。\n3.2.6.2 数组 Array 数组也是一种常见的复合数据类型，但是与元组不同的是，数组中的数据的类型必须是同一种。与某些语言不同的是，Rust 中的数组长度是固定的。\n我们通常使用 [] 来将一组数框起来作为数组。如下所示：\n1 let a = [1, 2, 3, 4, 5]; 和之前介绍的类型一样，数组的声明会从“栈（stack）”中申请内存，而不是“堆（heap）”中。而“向量（vector）”不同，它是分配在堆区的，所以它可以自由的增加或减少。如果您不确定是否应该使用数组或向量，那么您很可能应该使用向量。我们将在后面的章节详细阐述这一点。\n然而，当你知道元素数量不会改变时，数组更有用。例如，如果你在程序中使用月份的名称，你可能会使用数组而不是向量，因为你知道它总是包含 12 个元素：\n1 2 let months = [\u0026#34;January\u0026#34;, \u0026#34;February\u0026#34;, \u0026#34;March\u0026#34;, \u0026#34;April\u0026#34;, \u0026#34;May\u0026#34;, \u0026#34;June\u0026#34;, \u0026#34;July\u0026#34;, \u0026#34;August\u0026#34;, \u0026#34;September\u0026#34;, \u0026#34;October\u0026#34;, \u0026#34;November\u0026#34;, \u0026#34;December\u0026#34;]; 您使用方括号来编写数组的类型，其中包含每个元素的类型、分号，然后是数组中的元素数量，如下所示：\n1 let a: [i32; 5] = [1, 2, 3, 4, 5]; 在这里，i32 就是这个数组的数据类型。\n同样，我们也可以指定数组的初始值。如下所示：\n1 let a = [3; 5]; 此处，我们就声明了一个叫做 a 的数组，有 5 个成员初始值都为 3。等同于 let a = [3, 3, 3, 3, 3];\n数组是一个已知大小且固定大小的内存块，可以在栈上分配。你可以使用索引来访问数组的元素，就像这样：\n1 2 3 4 5 fn main() { let a = [1, 2, 3, 4, 5]; let first = a[0]; let second = a[1]; } 在这个例子中，名为 first 的变量将获得值 1 ，因为这是数组中索引 [0] 的值。名为 second 的变量将从数组中的索引 [1] 获得值 2 。\n和其他语言一样，数组会存在越界现象，比如下面的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 use std::io; fn main() { let arry:[u32;5] = [0,1,2,3,4]; println!(\u0026#34;please input a index:\u0026#34;); let mut index = String::new(); io::stdin().read_line(\u0026amp;mut index).expect(\u0026#34;Read Error\u0026#34;); let index:usize = index.trim().parse().expect(\u0026#34;Parse Error\u0026#34;); let element = arry[index]; println!(\u0026#34;The value of the element at index {index} is: {element}\u0026#34;); } 如果我们输入的索引值超过了 4，那么就会看到如下报错： 程序在使用索引操作时无效值导致运行时错误。程序退出并显示错误消息，未执行最后的 println! 语句。当你尝试使用索引访问元素时，Rust 会检查你指定的索引是否小于数组长度。如果索引大于或等于长度，Rust 将发生 panic。这个检查必须在运行时进行，特别是这种情况，因为编译器不可能知道用户在后期运行代码时会输入什么值。\n这是 Rust 内存安全原则的一个实例。在许多低级语言中，这种检查不会进行，当你提供错误的索引时，可能会访问无效的内存。Rust 通过立即退出而不是允许内存访问并继续来保护你免受这种错误的影响。\n3.3 函数(Functions) 函数在 Rust 代码中非常普遍。你已经见过语言中最重要之一的函数： main 函数，它是许多程序的入口点。你还见过 fn 关键字，它允许你声明新的函数。\n在 Rust 中，多使用蛇形命名法来对一个函数命名。所谓蛇形命名法，就是将函数名按照“小写字母 + 下划线”的组合进行命名。如下面的两个例子：\n1 2 3 4 5 6 7 8 fn main() { println!(\u0026#34;Hello, world!\u0026#34;); function(); } fn function() { println!(\u0026#34;function call\u0026#34;); } 和 C 语言一样，我们使用 {} 来将一个函数括起来，表示这个函数的作用域，来表明函数的开始和结束。\n同时我们可以注意到，我们明明在 main 函数之后声明的这个 function，但是我们依旧可以在 main 函数中调用这个函数。因为在 Rust 中，编译器并不像 C 语言的编译器一样那么严格要求函数的声明必须要在调用之前；不论你在哪里定义了这个函数，你都可以调用。\n3.3.1 参数(parameters) 上文我们定义的 another_function，没有入参。在 Rust 中，我们也可以定义拥有入参的函数。技术上，具体的值被称为实参（arguments），但在日常对话中，人们往往将参数（parameter）和实参这两个词混用，指代函数定义中的变量或调用函数时传入的具体值。\n1 2 3 4 5 6 7 8 fn main() { println!(\u0026#34;Hello, world!\u0026#34;); function(10); } fn function(x:i32) { println!(\u0026#34;x is {x}\u0026#34;); } 我们修改了我们的 function，给他添加了一个数据类型为 i32 的入参 x，其函数功能就是将它的值打印出来。\n在定义函数的时候，我们必须显式的指定我们每一个入参的数据类型。同样我们也可以定义一个有多个入参的函数，如下：\n1 2 3 4 5 6 7 8 fn main() { println!(\u0026#34;Hello, world!\u0026#34;); function(10,\u0026#39;h\u0026#39;); } fn function(x:i32, y:char) { println!(\u0026#34;x is {x},y is {y}\u0026#34;); } 1 2 3 结果： Hello, world! x is 10,y is h 如果我们想要入参是一个字符串而不是单纯是一个指针，我们首先想到的代码如下：\n1 2 3 4 5 6 7 8 fn main() { println!(\u0026#34;Hello, world!\u0026#34;); function(10, \u0026#34;N1netyNine99\u0026#34;); } fn function(x: i32, y: str) { println!(\u0026#34;x is {x},y is {y}\u0026#34;); } 在这段代码中我们直接指定 y 的数据类型是 str 字符串型，然后在调用函数的时候传入我们想要的字符串即可，可是我们编译运行发现不能通过编译。编译器报错如下图：\n我们查看编译器的第一个报错，它说 function 在 y 的位置预期得到的是一个 str 类型，但是我们传入的 \u0026quot;N1netyNine99\u0026quot; 确实一个 \u0026amp;str 类型。这让我很疑惑，但是我们按下不表，接着看下面的报错。后面两个报错的都是 doesn't have a size known at compile-time，意思是在编译的时候不知道大小。经过我的查询，Rust 作为一个严格的内存安全的语言，其不允许任何可能造成内存错误的事情发生，就比如我们想要传入一个不知道大小的数据。在 Rust 中，str 和 \u0026amp;str 是两种不同的数据类型；前者是一个抽象的数据类型，表示一段 UTF-8 字符串，它是动态大小类型(DST)，编译时不知道具体大小。而 \u0026amp;str 它是对 str 的借用引用，\u0026amp;str 本质是一个胖指针(fat pointer)，它包含了两个部分：一个指向实际字符串数据的内存地址的指针、字符串的字节长度；\u0026amp;str 的大小是固定的，在 64 位系统中总是 16 字节(8 字节指针 + 8 字节长度)。所以可以使用，因为编译器清楚的知道其大小。\n[!NOTE]\n想象一下：\nstr 就像 \u0026ldquo;一本书的内容\u0026rdquo; - 你知道有内容，但不知道有多少页 \u0026amp;str 就像 \u0026ldquo;书签 + 页数标记\u0026rdquo; - 告诉你内容在哪里，有多少页 所以我们对代码修改一下:\n1 2 3 4 5 6 7 8 fn main() { println!(\u0026#34;Hello, world!\u0026#34;); function(10, \u0026#34;N1netyNine99\u0026#34;); } fn function(x: i32, y: \u0026amp;str) {//使用\u0026amp;str而非str println!(\u0026#34;x is {x},y is {y}\u0026#34;); } 编译运行之后就发现可以正常运行了！\n3.3.2 语句（Statement）和表达式（Expression） 函数体由一系列可选以表达式结尾的语句组成。到目前为止，我们讨论过的函数还没有包含结尾表达式，但你已经见过表达式作为语句的一部分。由于 Rust 是一种基于表达式的语言，理解这一点非常重要。其他语言没有这样的区别，所以让我们看看语句和表达式是什么，以及它们的差异如何影响函数体。\n语句是执行某些操作，但是没有返回值。 表达式是经过一些计算，然后返回一个值。 1 2 3 fn main(){ let y = 5; } 比如上述的 let y = 5; 就是一个语句，它没有任何的返回值。所以下列的操作是明确禁止的：\n1 2 3 fn main(){ let y = (let x = 5); } 编译器报错说 error: expected expression, found let statement，这也与我们上述的表述相同。let x = 5 语句不返回值，所以 y 没有可以绑定到的东西。这与 C 语言和 Ruby 等其他语言不同，在这些语言中，赋值会返回赋值的值。在这些语言中，你可以写 x = y = 6 ，让 x 和 y 都具有值 `5 ；在 Rust 中则不是这种情况。\n在 Rust 中，使用 {} 可以创建一个表达式，表达式是有返回值的。\n1 2 3 4 5 6 7 fn main() { let x = { let y = 1; y + 1 }; println!(\u0026#34;x is {x}\u0026#34;); } 在这个例子中，我们给 x 的赋值就是一个表达式，这个表达式的返回值就是第 4 行的 y + 1，由于我们在第三行定义了 y 是 1，那么这个表达式的返回值就是 1 + 1 即 2，所以我们打印出来的值就是 2。\n注意 y + 1 行末尾没有分号，这与你之前看到的绝大多数行不同。表达式不包括结束分号。如果你在表达式末尾添加分号，它会变成一个语句，并且不会返回值。在接下来探索函数返回值和表达式时，请记住这一点。\n3.3.3 带返回值的函数 函数可以向调用它们的代码返回值。我们不命名返回值，但必须在箭头（ -\u0026gt; ）之后声明它们的类型。在 Rust 中，函数的返回值与函数体块中最后一条表达式的值是同义的。你可以使用 return 关键字并指定一个值来提前返回函数，但大多数函数会隐式地返回最后一条表达式。下面是一个返回值的函数示例：\n1 2 3 4 5 6 7 8 fn five() -\u0026gt; i32 { 5 } fn main() { let x = five(); println!(\u0026#34;The value of x is: {x}\u0026#34;); } 运行这段代码，你会看见终端显示 The value of x is: 5，表明 5 已经正确返回到了调用它的主函数当中。我们也可以使用 return 来返回一个值或者表达式：\n1 2 3 4 5 6 7 8 fn five() -\u0026gt; i32 { return 5; } fn main() { let x = five(); println!(\u0026#34;The value of x is: {x}\u0026#34;); } 其效果和上面的代码一样。\n在上述的代码中，我们使用了一个无入参，返回值为 i32 的函数来对一个变量初始化了，同样的，我们可以通过使用一个带参数的函数来达到初始化一个变量的目的：\n1 2 3 4 5 6 7 8 9 fn x_add_y(x: i32, y: i32) -\u0026gt; i32 { x + y //等价于return x + y; } fn main() { let x = x_add_y(1,2); println!(\u0026#34;The value of x is: {x}\u0026#34;); } 此时我们 x 的值就是 3。但是我们对代码稍作修改：\n1 2 3 4 5 6 7 8 fn x_add_y(x: i32, y: i32) -\u0026gt; i32 { x + y;//添加了; } fn main() { let x = x_add_y(1,2); println!(\u0026#34;The value of x is: {x}\u0026#34;); } 编译后运行发现: 这是因为，函数声明中显示说将会返回一个 i32 类型的值。但是我们的函数体内部，没有显式的返回值，第二行代码也只是简单的对 x 和 y 执行了一次加法，并且由于以 ; 结尾，表明这是一个语句，没有返回值。那么函数的返回值便是 ()，我们之前提到过，其数据类型是 unit，与我们的预取 i32 并不符合，所以编译器报错了。\n3.4 注释 所有程序员都力求让他们的代码易于理解，但有时需要额外的解释。在这种情况下，程序员会在他们的源代码中留下注释，编译器会忽略这些注释，但阅读源代码的人可能会觉得有用。\n这是一个简单的注释：\n1 //我是一个注释 在 Rust 中，惯用的注释风格以两个斜杠开始注释，注释内容持续到行尾。对于跨越多行的注释，你需要在每一行都包含 // ，像这样：\n1 2 3 //我是注释1号 //我是注释2号 //我是注释3号 注释也可以放在包含代码的行末：\n1 2 3 fn main() { let lucky_number = 7; //我是一个注释 } [!NOTE]\n官方文档中没有提到，但是在我的开发环境中（vscode）确实是可以通过 /* */ 来达到和 C 语言一样的注释风格。\n3.5 控制流 能够在条件为 true 时运行某些代码，以及在条件为 true 时重复运行某些代码，是大多数编程语言中的基本构建块。让 Rust 代码执行流控制的最常见结构是 if 表达式和循环。\n3.5.1 if 分支 一个 if 表达式允许你根据条件分支你的代码。你提供一个条件，然后说明，“如果这个条件满足，运行这块代码。如果条件不满足，不要运行这块代码。”\n所有 if 表达式都以关键词 if 开头，后面跟着一个条件。我们将要执行的代码块立即放在大括号内的条件后面。与 if 表达式中的条件关联的代码块有时被称为臂，就像我们在第 2 章的“比较猜测值与秘密数字”部分讨论的 match 表达式中的臂一样。\n我们也可以选择包含一个 else 表达式，以便在条件评估为 false 时给程序提供一个可执行的代码块。如果你不提供 else 表达式并且条件为 false ，程序将直接跳过 if 块并继续执行下一段代码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 use std::io; fn main() { println!(\u0026#34;Please input a number:\u0026#34;); loop { let mut input = String::new(); //要把创建变量放在循环里面 //因为read_line只会在input变量中追加，而不是覆盖 //所以如果把这句话放到loop中，只要第一次输入的是字符串 //即使后面输入的是数字，也无法解析 //因为之前的字符串还在变量中存储着的 //放到循环内部每次循环开始都会自动清空变量 io::stdin().read_line(\u0026amp;mut input).expect(\u0026#34;Fail to Read!\u0026#34;); let input: u32 = match input.trim().parse() { //强制类型转换的时候要指定数据类型！ Ok(num) =\u0026gt; num, Err(_) =\u0026gt; { println!(\u0026#34;Please input a number!\u0026#34;); continue; } }; if input \u0026lt; 5 { println!(\u0026#34;number {input} is less than 5\u0026#34;); break; } else if input == 5 { println!(\u0026#34;number {input} is equal to 5\u0026#34;); break; } else { println!(\u0026#34;number {input} is gearter than 5\u0026#34;); break; } } } 例如这段代码，其功能就是从终端中读取用户输入的值来与 5 作比较，根据不同的比较结果来向终端中打印不同的语句。注意，我们这里使用了 loop 和 match 来处理如果用户输入的值不是一个数字的情况，顺道复习了一下第二章所学习到的内容。\n在 Rust 中，控制分支的条件必须是一个布尔值。而不能像 C 语言一样使用一个整型来当作 if 的条件。例如下面的代码就是不合法的：\n1 2 3 4 5 6 fn main() { let number = 3; if number { println!(\u0026#34;number was three\u0026#34;); } } 编译运行这段代码会发现编译器报错如下:\n报错表明 Rust 期望一个 bool ，但得到的是一个整数。与 Ruby 和 JavaScript 等语言不同，Rust 不会自动尝试将非布尔类型转换为布尔类型。你必须明确指定，并且始终使用布尔值作为 if 的条件。例如，如果我们希望 if 代码块仅在数字不等于 0 时执行，我们可以将 if 表达式更改为以下内容：\n1 2 3 4 5 6 7 fn main() { let number = 3; if number != 0 { println!(\u0026#34;number was something other than zero\u0026#34;); } } 在 Rust 中，我们可以在一个语句中使用 if，例如下面的一段代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 use std::io; fn main() { println!(\u0026#34;please input a number:\u0026#34;); loop { let mut input = String::new(); io::stdin().read_line(\u0026amp;mut input).expect(\u0026#34;Fail to Read\u0026#34;); let input: i32 = match input.trim().parse() { Ok(value) =\u0026gt; value, Err(_) =\u0026gt; { println!(\u0026#34;please input a number!\u0026#34;); continue; } }; let condition = if input \u0026gt; 100 { true } else { false }; println!(\u0026#34;{input} \u0026gt; 100 is {condition}\u0026#34;); break; } } 上述代码中，程序从终端中读取一个值，如果这个值不是一个数字，那么就会让程序回到循环开始再次读取，直到读取到一个数字。之使用这个输入的数字与 100 做比较，通过 if-else 与表达式结合，来对布尔类型的变量 condition 赋值，最后打印出对应的消息然后终止循环。\n在这里我们就把 if-else 分支巧妙的与赋值语句结合在一起了，让程序更加清晰和明了。但是，上述例子中的两个分支的值都是整型，如果两个分支的类型不同，编译器将会报错。例如我把 false 变成 0。编译后会发现如下报错： 因为变量具有单一性，编译器在编译的时候不知道用户会输入什么，但是不同的输入可能造成变量的类型不同。Rust 是不允许这种未知的情况发生，所以报错来阻止编译。如果编译器必须跟踪任何变量的多个假设类型，编译器会更复杂，并且会减少对代码的保证。\n3.5.2 循环分支 有时需要多次执行一段代码。为此，Rust 提供了多种循环，这些循环会执行循环体内的代码直到结束，然后立即重新开始。而 Rust 为我们提供了三种循环方式：while、for、loop。\n3.5.2.1 从 loop 循环中返回值 loop 对我们并不陌生，在之前的章节已经多次学习并且使用了这个循环。但是 loop 还有一个功能，那就是在循环结束的时候可以返回一个值。看如下代码：\n1 2 3 4 5 6 7 8 9 10 fn main() { let mut counter = 0; let value = loop { counter += 1; if counter \u0026gt;= 10 { break counter * 5; } };//所有的语句都需要;结尾 println!(\u0026#34;counter = {counter}, value = {value}\u0026#34;); } *上述的代码中，变量 vlaue 的值就是通过一个 loop 循环的结束来赋予。我们把循环次数 5 赋值给我们的 value 变量。你也可以在循环内部使用 return 。虽然 break 只会退出当前循环，但 return 总是会退出当前函数。 但是在这里不能使用 return，因为 return 会直接退出当前的函数，也就是 main 函数，但是我们明确制定了 main 函数是一个返回值为 unit 的函数，不能返回一个整型。\n3.5.2.2 循环标签（Loop Labels） 对于嵌套多层的循环，单纯的 break 和 continue 只能适用于其所在位置的最内侧循环。但是使用循环标签，我们可以指定结束哪一个循环。循环标签必须以单引号开头。这里有一个包含两个嵌套循环的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 fn main() { let mut outter_loop_counter = 0; //外部循环的次数 \u0026#39;outter_loop_label: loop { println!(\u0026#34;outter loop counter:{outter_loop_counter}\u0026#34;); let mut remain_loop_counter = 10; //剩余循环次数 loop { println!(\u0026#34;remain loop counters: {remain_loop_counter}\u0026#34;); if remain_loop_counter == 9 { break; } if outter_loop_counter == 2 { break \u0026#39;outter_loop_label; //使用循环标签让内部循环直接终止外部循环 } remain_loop_counter -= 1; } outter_loop_counter += 1; } println!(\u0026#34;all the loops end. outter loop counter is {outter_loop_counter}\u0026#34;); } 外层循环有标签 'outter_loop_label ，它会从 0 计数到 2。内层循环没有标签，会从 10 计数到 9。第一个没有指定标签的 break 只会退出内层循环。 break 'outter_loop_label; 语句会退出外层循环。这段代码打印：\n3.5.2.3 while——条件循环 在编程中，我们经常遇到条件循环。只有当条件为真的时候，程序持续进行循环；一旦条件为假之后，程序会自动 break 循环。就像我们之前的“如果用户输入的是一个数字，则跳出循环”。我们之前的策略是使用 if-else 结合 loop 和 break 来达到同样的效果，接下来，我们可以使用 while，来让程序达到条件之后自动停止循环。\n1 2 3 4 5 6 7 8 fn main() { let mut loop_count = 5; while loop_count != 0 { println!(\u0026#34;there is still {loop_count} times loop\u0026#34;); loop_count -= 1; } println!(\u0026#34;all the loops end\u0026#34;); } 这段代码中，我们设定了一个倒计时值 loop_count，循环体内我们就打印当前的这个倒计时值。当这个倒计时值不为 0 的时候，我们就执行循环。结束循环之后就让程序提示我们循环结束了。\n执行效果如下:\n3.5.2.4 使用循环遍历复合类型数据元素 你可以选择使用 while 结构来遍历集合的元素，例如下列代码:\n1 2 3 4 5 6 7 8 9 10 fn main() { let arry: [i32; 5] = [10, 20, 30, 40, 50]; let mut index = 0; while index \u0026lt; 5 { println!(\u0026#34;arry[{}] = {}\u0026#34;, index, arry[index]); index += 1; } println!(\u0026#34;all the loops end\u0026#34;); } 编译运行结果如下： [!NOTE]\n笔者在初次编写这个代码的时候，在定义 index 变量的时候使用的语句是 let mut index:i32 = 0；，但是 Rust 的编译器报错。因为访问数组的变量类型预期的数据类型是 usize，即使是 u32、u64 的数据类型都不可以。对此我只能说，不愧是 Rust，不是在和编译器斗智斗勇就是在和编译器斗智斗勇的路上。:flushed:\n除了使用 while 循环，我们更推荐使用 for 循环来达到遍历的目的。如下列代码所示：\n1 2 3 4 5 6 7 8 fn main() { let array: [i32; 5] = [10, 20, 30, 40, 50]; println!(\u0026#34;array value below:\u0026#34;); for i in array { println!(\u0026#34;{}\u0026#34;, i); } } 我们使用 for 循环去遍历得到数组的所有元素，i 在每次遍历都直接得到了数组在该位置对应的元素值。比如第一次循环的时候 i 的值就是 10，等价于 array[0]；所以我们使用 for 循环的时候，就不需要再去使用索引来引用数组的元素值了。不过由于元组的每个元素可能都是不一样的数据类型，也不能使用 for 来遍历元组，想要获取元组的值，我们更建议使用之前提到过的解构来获取其值。\nfor 循环除了可以遍历一个数组，它还可以做到指定循环次数。比如下列的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 fn main() { println!(\u0026#34;count up below:\u0026#34;); for i in (1..10) { //这里的括号可加可不加 println!(\u0026#34;{i}\u0026#34;); } println!(\u0026#34;count down below:\u0026#34;); for i in (1..10).rev() { //这里的括号必须加 println!(\u0026#34;{i}\u0026#34;); } println!(\u0026#34;program over\u0026#34;); } 在这里，我们使用了 for 循环先正着从 1 到 9，然后从 9 走到 1。在 Rust 中，（x..y） 的含义是[x, y)，左闭右开。而我们看见的 rec() 方法，是将一个序列按照他的反方向读取。所以编译运行之后就可以看见如下情况：\n3.6 课后训练 3.6.1 编写一个华氏度和摄氏度相互转换的程序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 use std::io; fn temprature_f_c_convert(temp: f32, f_c: char) -\u0026gt; f32 { let mut temp_res = f32::default(); //默认值 f32不是一个动态数据类型 所以没有String那样的new()方法 match f_c { \u0026#39;C\u0026#39; =\u0026gt; temp_res = 9f32 * (temp / 5f32) + 32f32,//摄氏度转华氏度 \u0026#39;F\u0026#39; =\u0026gt; temp_res = 5f32 * (temp - 32f32) / 9f32,//华氏度转摄氏度 _ =\u0026gt; temp_res = temp, //错误处理 类似于default } return temp_res; } fn main() { let mut temp_now = String::new(); //当前温度 let mut temp_f_c = String::new(); //当前温度类型 //使用loop循环中断来赋值 let temp_f_c: char = loop { let mut temp_f_c = String::new(); //当前温度类型 println!(\u0026#34;Please input what kind of unit of your temprature(C or F):\u0026#34;); io::stdin().read_line(\u0026amp;mut temp_f_c).expect(\u0026#34;Fail to Read\u0026#34;); match temp_f_c.trim().parse::\u0026lt;char\u0026gt;() { //::\u0026lt;x\u0026gt;是让parse方法转换成x类型 Ok(c) =\u0026gt; { if c == \u0026#39;C\u0026#39; || c == \u0026#39;F\u0026#39; { break c; } else { println!(\u0026#34;please input F or C!\u0026#34;); } } Err(_) =\u0026gt; println!(\u0026#34;invalid input, please try again.\u0026#34;), } }; let temp_now = loop { let mut temp_now = String::new(); //当前温度 println!(\u0026#34;Please input temp value you want to convert:\u0026#34;); io::stdin().read_line(\u0026amp;mut temp_now).expect(\u0026#34;Fail to Read\u0026#34;); match temp_now.trim().parse::\u0026lt;f32\u0026gt;() { Ok(value) =\u0026gt; break value, Err(_) =\u0026gt; println!(\u0026#34;invalid input, please try again.\u0026#34;), } }; println!(\u0026#34;your input:{temp_now} with unit {temp_f_c}\u0026#34;); println!(\u0026#34;start convert ...\u0026#34;); let temp_after = temprature_f_c_convert(temp_now, temp_f_c); let temp_f_c_after = match temp_f_c { \u0026#39;C\u0026#39; =\u0026gt; \u0026#39;F\u0026#39;, \u0026#39;F\u0026#39; =\u0026gt; \u0026#39;C\u0026#39;, _ =\u0026gt; \u0026#39;C\u0026#39;, //错误处理 类似于default 这是必须的！ }; println!(\u0026#34;convert finished!\u0026#34;); println!(\u0026#34;{temp_now} {temp_f_c} =\u0026gt; {temp_after} {temp_f_c_after}\u0026#34;); } 3.6.2 生成第 n 个斐波那契数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 use std::io; //斐波那契数:从第二项开始，每一项都是前两项的和 fn fibonacci(n: u64) -\u0026gt; u64 { if n == 0 || n == 1 { return n; } let mut now_value: u64 = 1; //n = 2的时候 let mut last_value: u64 = 0; //上一次的值 for i in (2..n + 1) { //左开右闭 第n项的条件是n+1 let next_value = now_value + last_value; //新值 = 当前值+上一次值 last_value = now_value; //更新上一项的值 now_value = next_value; //更新当前值 } return now_value; } fn main() { let n = loop { let mut n = String::new(); println!(\u0026#34;Please input n:\u0026#34;); io::stdin().read_line(\u0026amp;mut n).expect(\u0026#34;Fail to Read\u0026#34;); match n.trim().parse::\u0026lt;u64\u0026gt;() { Ok(num) =\u0026gt; break num, Err(_) =\u0026gt; println!(\u0026#34;n must be a int!\u0026#34;), } }; let fibo = fibonacci(n); println!(\u0026#34;when n={n},the fibonaci number is {fibo}\u0026#34;); } Chapter 4：所有权(Ownership) 4.1 什么是所有权？ 所有权是一套管理 Rust 程序如何管理内存的规则。所有程序都必须在运行时管理它们使用计算机内存的方式。有些语言有垃圾回收机制，会定期在程序运行时查找不再使用的内存；在其他语言中，程序员必须显式地分配和释放内存。Rust 采用第三种方法：通过一套编译器会进行检查的所有权规则系统来管理内存。如果任何规则被违反，程序将无法编译。所有权的所有特性都不会在程序运行时减慢其速度。\n[!TIP]\n堆(heap) 和 栈(stack)\n在许多编程语言中，开发者通常无需频繁考虑栈（stack）和堆（heap）的概念。但在系统级编程语言（如 Rust）中，值的存储位置（栈或堆）会直接影响语言的行为模式，并决定了开发者必须做出的某些设计选择。本章后续讲解所有权（ownership）时，会频繁涉及栈与堆的关系，因此这里先简要阐明二者的区别。\n栈与堆均为程序运行时可供使用的内存区域，但它们的结构截然不同：\n栈 以严格的 后进先出（LIFO） 顺序存储数据。想象一叠盘子：新盘子只能放在顶部，取用时也只能从顶部拿取（不可从中间或底部操作）。数据的存入称为 压栈（push），移除称为 出栈（pop）。所有存储在栈中的数据必须具有 编译期已知的固定大小，无法满足此条件的数据必须存放在堆中。\n堆 的组织更为松散：在堆上存储数据时，需先申请特定大小的空间。内存分配器（allocator）会在堆中找到足够大的空闲区域，将其标记为已占用，并返回指向该位置的 指针（即内存地址），此过程称为 堆分配（allocating）。由于堆指针本身是固定大小的，它可以被存储在栈上，但访问实际数据时需通过指针跳转。类比餐厅等位：入场时告知人数，服务员会安排合适餐桌并引导入座；若有人迟到，只需根据桌号定位即可。\n性能关键差异：\n速度：压栈操作远快于堆分配，因为栈的写入位置永远在顶部（无需搜索空闲内存），而堆分配需先寻找足够空间并维护分配记录。 访问效率：访问堆数据通常更慢，因为需要通过指针间接寻址。现代处理器对连续内存访问（如栈）有优化，而随机跳转（如堆）会降低缓存命中率。延续餐厅类比：服务员若在 A、B 两桌间反复切换处理订单，效率必然低于集中处理完一桌再处理下一桌。 函数调用时的内存行为：\n调用函数时，其参数（可能包含堆数据的指针）和局部变量会被压入栈中，函数结束时这些值自动出栈。 所有权的核心意义： 所有权机制正是为了解决堆数据管理的三大难题：\n跟踪代码中哪些部分正在使用堆数据 最小化堆上的重复数据 及时清理无用的堆数据以避免空间耗尽 理解所有权后，开发者虽不必再频繁思考栈与堆的细节，但明确 \u0026ldquo;所有权的主要目的是管理堆数据\u0026rdquo; 这一本质，能帮助理解其设计逻辑的深层原因。 4.1.1 所有权规则： 每个值都有一个所有者(owner)。 同一时间，一个值只能被一个所有者拥有。 当程序超出所有者的作用域，其所有的值会被舍弃。 4.1.2 变量的作用域(Scope) 作用域是指程序中某个项目有效的范围。以下是一个变量：\n1 2 3 4 5 fn main() {//S在这里是无效的，因为还没声明 let s = \u0026#34;Hello World\u0026#34;; //从这里开始 s开始有效了 //其他操作... //在这些操作中，s都是有效的，因为在其作用域中 }//现在这个作用域结束了，s重新变得无效了 变量 s 指向一个字符串字面量，其中字符串的值硬编码在程序的文本中。该变量从声明点开始直到当前作用域的末尾都有效。此时，作用域与变量有效性的关系与其他编程语言相似。现在我们将基于这一理解，引入 String 类型。\n4.1.3 String 类型 为了说明所有权规则，我们需要一个比第三章“数据类型”部分所涵盖的更复杂的数据类型。之前涵盖的类型是已知大小的，可以存储在栈上，在其作用域结束时从栈中弹出，并且可以快速且简单地复制以创建一个新的独立实例，如果代码的其他部分需要在不同的作用域中使用相同的值。但我们想要查看存储在堆上的数据，并探索 Rust 何时清理这些数据，而 String 类型就是一个很好的例子。\n我们已经见过字符串字面量，其中字符串值被植入到我们的程序中。字符串字面量很方便，但它们并不适用于我们可能想要使用文本的每种情况。一个原因是它们是不可变的。另一个原因是并非每个字符串值在我们编写代码时都能知道：例如，如果我们想要获取用户输入并将其存储起来怎么办？对于这些情况，Rust 有一种第二种字符串类型，即 String 。这种类型管理堆上分配的数据，因此能够存储编译时我们不知道数量的文本。你可以使用 from 函数从一个字符串字面量创建一个 String ，就像这样：\n1 2 3 4 fn main(){ let s = String::from(\u0026#34;hello\u0026#34;); println!(\u0026#34;{s}\u0026#34;); } 很自然的我们就能想到，这个 String 和我们之前使用的 String，两者有何区别呢？\n有一个很显著的区别就是，后者是可变的:\n1 2 3 4 5 fn main(){ let mut s = String::from(\u0026#34;hello\u0026#34;); s.push_str(\u0026#34;, N1netyNine99!\u0026#34;); // push_str() 在原本的字符串之后追加了字符串 println!(\u0026#34;{s}\u0026#34;); // 这将会打印出`hello, N1netyNine99!` } 4.1.4 内存与分配 在字符串字面量的情况下，我们知道编译时的内容，因此文本直接硬编码到最终的可执行文件中。这就是为什么字符串字面量速度快且高效的原因。但这些特性只来自于字符串字面量的不可变性。不幸的是，我们不能为每个在编译时大小未知且运行时大小可能会变化的文本块在二进制文件中放入一块内存。\n使用 String 类型，为了支持一个可变且可增长的文本，我们需要在堆上分配一段在编译时未知大小的内存来存储内容。这意味着：\n内存必须在运行时从内存分配器请求。 我们需要一种方式在完成对 String 的使用后将这块内存返回给分配器。 第一部分是由我们完成的：当我们调用 String::from 时，它会向堆申请内存。这在编程语言中几乎是通用的。\n然而，第二部分是不同的。在具有垃圾收集器（GC）的语言中，垃圾收集器会跟踪并清理不再使用的内存，我们不需要考虑这些。在大多数没有垃圾收集器的语言中，我们需要自己识别不再使用的内存，并调用代码显式地释放它，就像我们请求内存时所做的那样。正确地做到这一点历来是一个困难的编程问题。如果我们忘记了，我们会浪费内存。如果我们过早地释放，会导致变量无效。如果我们释放两次，这也是一种错误。我们需要一对一地配对 allocate 和 free 。\nRust 采取了不同的路径：内存会在拥有它的变量超出作用域时自动返回。比如下列代码:\n1 2 3 4 5 6 7 fn main() { { let s = String::from(\u0026#34;hello\u0026#34;); // s 在这之后都有效 // 某些操作 }// 这里作用域结束了 s不再是有效的 } 有一个自然的时机可以将 String 所需的内存返回给分配器：当 s 超出作用域时。当一个变量超出作用域时，Rust 会为我们调用一个特殊函数。这个函数叫做 drop ，作者可以在 drop 中放入返回内存的代码。Rust 会在闭大括号时自动调用 drop 。\n这种模式对 Rust 代码的编写方式产生了深远的影响。现在看来可能很简单，但在更复杂的情况下，当我们希望多个变量使用我们在堆上分配的数据时，代码的行为可能会出乎意料。我们现在就来探讨一些这种情况。\n4.1.5 变量和数据在运行中相互影响 多个变量可能会在程序中通过不同的方式相互影响。比如下列的例子\n1 2 3 4 fn main() { let x = 5; let y = x; } 显而易见的，我们先定义了一个变量 x 让它的值变成了 5，然后又让一个变量 y 与 x 也就是 5 绑定。这样的话 x 和 y 的值都是 5。并且由于 5 是一个整型，其大小固定且已知，这两个 5 都会入栈。\n但是如果是 String 类型，情况就有所不同了：\n1 2 3 4 fn main() { let s1 = String::from(\u0026#34;hello\u0026#34;); let s2 = s1; } 这看起来非常相似，所以我们可能会假设它的工作方式是相同的：也就是说，第三行会复制 s1 中的值并将其绑定到 s2 。但这并不是实际发生的真实情况。\n看看下图，了解 String 在底层发生了什么。一个 String 由三个部分组成，如图左侧所示：一个指向存储字符串内容的内存的指针、一个长度和一个容量(capacity)。这组数据存储在栈上。右侧是存储内容的堆内存。\n长度是指 String 的内容目前使用的内存大小（以字节为单位）。容量是指 String 从分配器那里获得的内存总大小（以字节为单位）。长度和容量之间的差异很重要，但在当前上下文中并不重要，因此暂时可以忽略容量。\n当我们把 s1 赋值给 s2 时， String 数据会被复制，这意味着我们复制了栈上的指针、长度和容量。我们不会复制指针所指向的堆上的数据。\n之前，我们说过当变量超出作用域时，Rust 会自动调用 drop 函数并清理该变量的堆内存。但上图显示两个数据指针都指向相同的位置。这是一个问题：当 s2 和 s1 超出作用域时，它们都会尝试释放同一块内存。这被称为双重释放错误，也是我们之前提到的内存安全漏洞之一。重复释放内存会导致内存损坏，这可能会引发安全漏洞。\n为确保内存安全，在行 let s2 = s1; 之后，Rust 将 s1 视为不再有效。因此，当 s1 超出作用域时，Rust 无需释放任何内容。看看在 s2 创建后尝试使用 s1 会发生什么；它将无法工作：\n1 2 3 4 5 6 fn main() { let s1 = String::from(\u0026#34;hello\u0026#34;); let s2 = s1; println!(\u0026#34;{s1}, world!\u0026#34;); } 你会得到类似这样的错误，因为 Rust 阻止你使用失效的引用：\n如果你在其他语言中听说过浅拷贝和深拷贝这两个术语，那么复制指针、长度和容量而不复制数据的概念听起来可能就像是在进行浅拷贝。但由于 Rust 也会使第一个变量失效，所以它不是被称为浅拷贝，而是被称为移动。在这个例子中，我们会说 s1 被移动到了 s2 。\n这样就解决了我们的问题！当只有 s2 有效时，当它超出作用域时，它将单独释放内存，我们就完成了。\n此外，还有一个由此暗示的设计选择：Rust 永远不会自动创建数据的“深度”副本。因此，任何自动复制都可以被认为是运行时性能上成本不高的。\n4.1.6 赋值与作用域 对于作用域、所有权以及通过 drop 函数释放内存之间的关系，情况也正好相反。当你给一个现有变量赋予一个全新的值时，Rust 会立即调用 drop 并释放原始值的内存。例如，考虑以下代码：\n1 2 3 4 5 6 fn main() { let mut s = String::from(\u0026#34;hello\u0026#34;); s = String::from(\u0026#34;ahoy\u0026#34;); println!(\u0026#34;{s},world!\u0026#34;);//将会打印 ahoy,world! } 我们最初声明一个变量 s 并将其绑定到值为 \u0026quot;hello\u0026quot; 的 String 。然后我们立即创建一个新的 String ，其值为 \u0026quot;ahoy\u0026quot; ，并将其赋给 s 。此时，没有任何东西再引用堆上的原始值了。\n因此原始字符串立即超出作用域。Rust 会运行 drop 函数处理它，并且内存会立即释放。当我们最后打印这个值时，它将是 \u0026quot;ahoy, world!\u0026quot; 。\n4.1.7 克隆（Clone） 如果我们想要深度复制 String 的堆数据，而不仅仅是栈数据，我们可以使用一个常见的方法—— clone 。我们将在第 5 章讨论方法语法，但由于方法在许多编程语言中都是常见特性，你可能之前已经见过它们了。\n这里是一个 clone 方法使用的示例：\n1 2 3 4 5 6 fn main() { let s1 = String::from(\u0026#34;hello\u0026#34;); let s2 = s1.clone(); println!(\u0026#34;s1 = {s1}, s2 = {s2}\u0026#34;);//打印 s1 = hello, s2 = hello } 这种方式运行得很好，其中堆数据确实被复制了。\n4.1.8 仅栈数据（Stack-Only Data）: 复制(Copy) 还有一个我们还没讨论过的细节。这段使用整数的代码，是有效且可以运行的：\n1 2 3 4 5 6 fn main() { let x = 5; let y = x; println!(\u0026#34;x = {x}, y = {y}\u0026#34;); } 但这段代码似乎与我们刚刚学到的知识相矛盾：我们没有调用 clone ，但 x 仍然有效，并且没有被移动到 y 。\n原因是像整数这样在编译时具有已知大小的类型完全存储在栈上，因此实际值的副本可以快速创建。这意味着在我们创建变量 y 之后，没有理由阻止 x 保持有效。换句话说，在这里深拷贝和浅拷贝没有区别，调用 clone 不会与通常的浅拷贝产生任何不同，因此我们可以省略它。\nRust 有一种特殊的特性叫做 Copy trait，我们可以将它用于存储在栈上的类型（比如整数）。如果一个类型实现了 Copy trait，那么使用该类型的变量在赋值给其他变量时不会发生移动（move），而是进行简单的复制（copy），因此原变量在赋值后仍然有效。\n如果某个类型或其任何部分实现了 Drop trait，Rust 将不允许我们为该类型添加 Copy 注解。当一个类型需要在值离开作用域时执行特殊操作时，如果我们为其添加 Copy 注解，就会导致编译时错误。\n那么哪些类型实现了 Copy trait 呢？你可以查看具体类型的文档来确认，但一般来说，任何简单的标量值集合都可以实现 Copy，而需要分配内存或是某种资源的形式的类型则不能实现 Copy。以下是一些实现了 Copy trait 的类型：\n所有整数类型，例如 u32。 布尔类型 bool，其值为 true 和 false。 所有浮点数类型，例如 f64。 字符类型 char。 元组（tuple），当且仅当其包含的所有类型都实现了 Copy 时。例如，(i32, i32) 实现了 Copy，但 (i32, String) 则没有。 4.1.9 函数与所有权 将值传递给函数的机制与将值赋给变量的机制相似。将变量传递给函数会移动或复制，就像赋值一样。比如下列代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 fn main() { let s = String::from(\u0026#34;N1netyNine99\u0026#34;); // `s` 进入作用域，它是一个 `String`（堆分配数据，没有 `Copy` trait） take_ownership(s); // `s` 被 **移动（move）** 到 `take_ownership` 函数中，`s` 在 `main` 中不再有效 // println!(\u0026#34;{s}\u0026#34;); // ❌ 这里不能再使用 `s`，因为它已经被移动（所有权转移） let x = 9999; // `x` 进入作用域，它是一个 `i32`（栈数据，实现了 `Copy` trait） only_copy(x); // `x` 被 **复制（copy）** 到 `only_copy` 函数中，`x` 在 `main` 中仍然有效 println!(\u0026#34;{x}\u0026#34;); // ✅ 可以继续使用 `x`，因为 `i32` 是 `Copy` 类型 } fn take_ownership(a_str: String) { // `a_str` 进入作用域（所有权从 `main` 转移到这里） println!(\u0026#34;{a_str}\u0026#34;); } // 函数结束，`a_str` 被 `Drop`，内存被释放 fn only_copy(a_int: i32) { // `a_int` 进入作用域（`i32` 是 `Copy`，所以这里是一个副本） println!(\u0026#34;{a_int}\u0026#34;); } // 函数结束，`a_int` 被丢弃（但 `main` 中的 `x` 不受影响） 如果我们尝试在调用 takes_ownership 之后使用 s ，Rust 会抛出一个编译时错误。这些静态检查可以保护我们免犯错误。尝试向 main 添加代码，使用 s 和 x ，看看你可以在哪里使用它们，以及所有权规则如何阻止你这样做。\n4.1.10 返回值和作用域 返回值也可以转移所有权。如下所示的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 fn main() { let s1 = give_ownership(); // `give_ownership` 返回 `String`，所有权转移给 `s1` let s2 = String::from(\u0026#34;九千九百九十九\u0026#34;); // `s2` 进入作用域，拥有该 `String` 的所有权 let s3 = transfer_ownership(s2); // `s2` 的所有权被移动到 `transfer_ownership`，然后返回值所有权转移给 `s3` println!(\u0026#34;{s1}\u0026#34;); // ✅ `s1` 仍然有效，可以打印 // println!(\u0026#34;{s2}\u0026#34;); // ❌ `s2` 的所有权已被转移，不能再使用 println!(\u0026#34;{s3}\u0026#34;); // ✅ `s3` 现在拥有所有权，可以打印 } // 该函数返回一个 `String`，所有权会转移给调用者 fn give_ownership() -\u0026gt; String { let temp = String::from(\u0026#34;N1netyNine99\u0026#34;); // `temp` 进入作用域，拥有该 `String` 的所有权 temp // `temp` 的所有权被返回（移动），`temp` 本身被移出作用域但数据所有权交给调用者 } // `temp` 的作用域结束，但由于所有权已转移，不会触发 `Drop` // 该函数接收一个 `String` 并返回它，所有权会转移给调用者 fn transfer_ownership(s: String) -\u0026gt; String { // `s` 进入作用域，所有权从调用者转移到这里 s // `s` 的所有权被返回（移动），`s` 本身被移出作用域但数据所有权交给调用者 } // `s` 的作用域结束，但由于所有权已转移，不会触发 `Drop` 变量的所有权每次都遵循同样的模式：将值赋给另一个变量会移动它。当包含堆上数据的变量超出作用域时，如果没有将数据所有权移动到另一个变量，值将会被 drop 清理。\n虽然这样可行，但每次函数获取所有权然后再返回所有权有点繁琐。如果我们想让一个函数使用某个值但不获取其所有权怎么办？如果我们要再次使用传递进来的任何内容，不仅需要将其传递回去，还需要处理函数体中可能要返回的任何数据，这确实很烦人。\nRust 确实允许我们使用元组返回多个值：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 fn main() { // 创建一个 String 类型变量 s1，拥有 \u0026#34;hello\u0026#34; 的所有权 let s1 = String::from(\u0026#34;hello\u0026#34;); // 调用 calculate_length 函数，传入 s1 // 函数返回一个元组，包含原字符串和其长度 // 这里发生了所有权的转移和返回： // 1. s1 的所有权被移动到 calculate_length 函数中 // 2. 函数处理完后，又将 String 的所有权通过返回值转移回 s2 let (s2, len) = calculate_length(s1); // 可以正常使用 s2，因为所有权已经通过返回值转移回来了 println!(\u0026#34;The length of \u0026#39;{s2}\u0026#39; is {len}.\u0026#34;); // 注意：这里不能再使用 s1，因为它的所有权已经被转移 } // 计算字符串长度的函数 // 参数：接收一个 String 类型（取得所有权） // 返回值：返回一个包含 String 和其长度的元组 fn calculate_length(s: String) -\u0026gt; (String, usize) { // 获取字符串的长度（不涉及所有权变化） let length = s.len(); // len() 返回字符串的字节长度 // 返回原字符串和其长度 // 这里将 s 的所有权通过返回值转移出去 (s, length) } // 函数结束时： // - 不会调用 s 的 drop 方法，因为所有权已经通过返回值转移 // - length 是基本类型，直接拷贝返回 但这对于一个应该很常见的概念来说，仪式太多，工作也太繁琐。幸运的是，Rust 有一种使用值而不转移所有权的功能——引用(Reference)。\n[!TIP]\n通过上述的这个例子，我们可以清除的知道一点：我们可以通过返回一个元组来让一个函数可以返回多个值。\n4.2 引用(References)和借用(Brorrow ing)模型 对于上面那个例子来说，我们必须将 String 返回给调用函数，这样我们才能在调用 calculate_length 之后仍然使用 String ，因为 String 已经被移动到 calculate_length 中了。相反，我们可以提供一个指向 String 值的引用。引用类似于指针，它是一个地址，我们可以通过这个地址来访问存储在该地址的数据；这些数据由其他某个变量拥有。与指针不同，引用保证在其生命周期内始终指向特定类型的有效值。\n以下是定义和使用一个参数为对象引用而不是值所有权的 calculate_length 函数的方法：\n1 2 3 4 5 6 7 8 9 10 fn main() { let s1: String = String::from(\u0026#34;hello\u0026#34;); let length = calculate_length(\u0026amp;s1); println!(\u0026#34;The length of \u0026#39;{s1}\u0026#39; is {length}.\u0026#34;); } fn calculate_length(s: \u0026amp;String) -\u0026gt; usize { return s.len(); } 首先，请注意变量声明和函数返回值中的所有元组代码都不见了。其次，请注意我们将 \u0026amp;s 传递给 calculate_length ，在其定义中，我们使用 \u0026amp;String 而不是 String 。这些 \u0026amp; 代表引用，它们允许你在不拥有值的情况下引用它。具体关系如下图所示：\n[!NOTE]\n使用 \u0026amp; 进行引用的反操作是解引用，这通过解引用操作符 * 完成。\n重新聚焦到上面的代码中，\u0026amp;s1 语法让我们能够创建一个引用，它引用 s1 的值但并不拥有它。由于引用不拥有它，当引用不再被使用时，它指向的值不会被丢弃。\n同样，函数的签名使用 \u0026amp; 来指示参数 s 的类型是指针。让我们添加一些解释性注释：\n1 2 3 4 fn calculate_length(s: \u0026amp;String) -\u0026gt; usize { // s是一个Sring的引用 return s.len(); } // 在这里，s的作用域结束了，但是由于s只是引用了String，并不是拥有其所有权 // 所以并不会触发`Drop`导致String被舍弃 变量 s 的有效范围与任何函数参数的有效范围相同，但当 s 停止使用时，引用所指向的值不会被丢弃，因为 s 没有所有权。当函数以引用作为参数而不是实际值时，我们不需要返回值来交还所有权，因为我们从未拥有过这些值。\n我们称创建引用的行为为借用(Brorrowing)。就像现实生活中一样，如果一个人拥有某物，你可以向他们借用。用完后，你必须归还。你并不拥有它。\n接下来让我们看看如果我们尝试对一个我们借用来的值进行修改，会发生什么：\n1 2 3 4 5 6 7 8 9 fn main(){ let mut s1 = String::from(\u0026#34;Hello\u0026#34;); change(\u0026amp;s1); println!(\u0026#34;{s1}\u0026#34;); } fn change(s:\u0026amp;String){ s.push_str(\u0026#34;,World\u0026#34;); } 在这个代码中，我们将 s1 的 String 借用给了函数 change 中的 s，并尝试在 s 的作用域中修改 String，但是编译后会发现如下报错： 这是因为和变量默认的不可变一样，引用默认也是不可变的。所以修改一个我们借用来的值，是不被允许的。\n4.2.1 可变的引用(mutable references) 我们可以对上述代码稍作修改，让它按照我们的意愿运行：\n1 2 3 4 5 6 7 8 9 fn main(){ let mut s1 = String::from(\u0026#34;Hello\u0026#34;); change(\u0026amp;mut s1);//加上mut println!(\u0026#34;{s1}\u0026#34;); } fn change(s:\u0026amp;mut String){//入参也改为mut String s.push_str(\u0026#34;,World\u0026#34;); } 修改过后就可以正常编译运行，我们可以看见终端中正确的打印出来我们想要的“Hello, World”了。\n我们只是将函数的入参改为预期接受一个 \u0026amp;mut String 类型，即一个可变的字符串类型；同样的，我们也要在调用的时候传入对应的类型。\n不过可变的引用有一个巨大限制：只能存在一个可变引用。当我们将一个值通过可变引用借用给了一个变量 a，那么我们就不能在 a 的作用域内再次借给 b。比如下列的代码：\n1 2 3 4 5 6 fn main(){ let mut s = String::from(\u0026#34;N1netyNine99\u0026#34;); let s1 = \u0026amp;mut s;//第一次 可变引用 let s2 = \u0026amp;mut s;//在上一次可变引用为消除的情况下 再次引用，这是不允许的 println!(\u0026#34;s1:{s1} s2:{s2}\u0026#34;); } 其报错的代码如下：\n报错中提到：我们不能在同一时间多次可变的借用 s。与之相对的，以下的代码都是是可以正常运行的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 fn main() { let mut s = String::from(\u0026#34;N1netyNine99\u0026#34;); let s1 = \u0026amp;s; let s2 = \u0026amp;s; println!(\u0026#34;s:{s} s1:{s1} s2:{s2}\u0026#34;);//注意：println!本身也是一种不可变引用 }//多次借用都是不可变借用 可以运行 fn main() { let mut s = String::from(\u0026#34;N1netyNine99\u0026#34;); //let s2 = \u0026amp;mut s; 如果尝试把首次借用放到s1的作用域之前 也是不允许的 { let s1 = \u0026amp;mut s; //进入s1的作用域 然后对s进行可变引用 println!(\u0026#34;s1:{s1}\u0026#34;); //println!本身也对s1进行了一次不可变引用 } //退出s1的作用域 所有权不再被s1借用 let s2 = \u0026amp;mut s; //将所有权可变借用给s2 println!(\u0026#34;s2:{s2}\u0026#34;); //println!本身也对s2进行了一次不可变引用 println!(\u0026#34;s:{s}\u0026#34;); //println!本身也对s进行了一次不可变引用 } 但是还有一种情况，我们自然而然的想到，我一个变量可变引用，另一个变量不可变引用，可否成功编译呢？如下列代码：\n1 2 3 4 5 6 fn main() { let mut s = String::from(\u0026#34;N1netyNine99\u0026#34;); let s1 = \u0026amp;mut s;//这里使用可变引用 let s2 = \u0026amp;s;//这里使用不可变引用 println!(\u0026#34;s:{s} s1:{s1} s2:{s2}\u0026#34;);//println!内部也是一个不可变引用 } 编译结果如下： 报错说，我们不能同时有可变引用和不可变引用。不可变引用的用户不会期望值突然从他们下面改变！然而，允许多个不可变引用，因为任何只是读取数据的人都没有能力影响其他人读取数据。\n这种限制的好处是 Rust 可以在编译时防止数据竞争。数据竞争类似于竞态条件，当出现以下三种行为时会发生：两个或多个指针同时访问相同的数据、至少有一个指针正在写入数据、没有机制用于同步对数据的访问。数据竞争会导致未定义行为，当你试图在运行时追踪它们时，诊断和修复它们可能很困难；Rust 通过拒绝编译存在数据竞争的代码来防止这个问题！\n尽管借用错误有时令人沮丧，但请记住，这是 Rust 编译器在编译时（而非运行时）指出了一个潜在的 bug，并明确告诉你问题所在。这样你就不必去追踪为什么你的数据不是你预期的样子了。\n4.2.2 悬垂引用(Dangling References) 在有指针语言中，很容易通过释放一些内存同时保留对该内存的指针，从而错误地创建悬垂指针——一个引用了内存中可能已被分配给其他人的位置的指针。相比之下，在 Rust 中，编译器保证引用永远不会是悬垂引用：如果你有一个指向某些数据的引用，编译器将确保这些数据不会在引用它们之前超出作用域。\n让我们尝试创建一个悬垂引用，看看 Rust 如何通过编译时错误来阻止它们：\n1 2 3 4 5 6 7 8 fn main() { let pointer_to_nothing = dangle(); } fn dangle() -\u0026gt; \u0026amp;String { let s = String::from(\u0026#34;hello\u0026#34;); //进入s的作用域 return \u0026amp;s; //将s的引用返回给调用的变量 } //此时已经超出s的作用域，s将被编译器drop 所以返回给调用变量的是一个悬挂引用 编译报错的结果如下： 这个错误信息指的是我们尚未讨论的一个特性：生命周期。我们将在第 10 章详细讨论生命周期。但是，如果你忽略关于生命周期的部分，这条信息确实包含了导致这段代码成为问题的关键：\nthis function\u0026rsquo;s return type contains a borrowed value, but there is no value for it to be borrowed from\n因为 s 是在 dangle 内部创建的，当 dangle 的代码执行完毕时， s 会被释放。但我们试图返回它的引用。这意味着这个引用将指向一个无效的 String 。这不行！Rust 不会允许我们这样做。\n解决方案是直接返回一个值，而不是其引用：\n1 2 3 4 5 6 7 8 fn main() { let value_of_string = dangle(); } fn dangle() -\u0026gt; String { let s = String::from(\u0026#34;hello\u0026#34;); return s;//将s的所有权给予给调用这个函数的变量 } 这没有任何问题。所有权被转移出去，没有任何内容被释放。\n4.2.3 引用的规则 任何时间，只能有一个可变引用或者多个不可变引用，但是不能两者都有。 引用必须始终有效，即不能出现悬挂引用。 4.3 切片（Slice） 切片让你能够引用集合中一个连续的元素序列，它是一种引用，因此不拥有所有权。\n我们来看一个编程问题：编写一个函数，它接受一个以空格分隔的单词字符串，并返回第一个单词。如果字符串中没有空格，则整个字符串就是一个单词，函数应该返回整个字符串。\n*为了更好地理解切片的作用，我们先尝试不使用它来解决这个问题。\n1 fn first_word(s: \u0026amp;String) -\u0026gt; ? first_word 函数接受一个 \u0026amp;String 类型的参数，这很好，因为我们不需要它的所有权。那么，我们该返回什么呢？我们没有一个直接的方式来描述字符串的一部分。一种方法是返回第一个单词末尾的索引，也就是空格的位置。\n1 2 3 4 5 6 7 8 9 10 fn first_word(s: \u0026amp;String) -\u0026gt; usize { let bytes = s.as_bytes(); for (i, \u0026amp;item) in bytes.iter().enumerate() { if item == b\u0026#39; \u0026#39; { // `b\u0026#39; \u0026#39;` 是字节字面量，代表一个空格 return i; // 找到空格，返回其索引 } } return s.len(); // 没有找到空格，返回字符串的长度 } 为了逐个检查字符串中的字节，我们使用 s.as_bytes() 将 String 转换为字节数组。然后，我们用 iter().enumerate() 来遍历数组。\n我们会在第 13 章更详细地学习迭代器。现在你只需要知道，iter 方法会返回集合中的每一个元素，而 enumerate 则会把 iter 的结果包装成一个元组，其中第一个元素是索引，第二个是元素的引用。这比我们手动追踪索引要方便得多。\nenumerate 返回元组，我们可以用模式（patterns）来解构它。我们会在第 6 章详细讨论模式。在 for 循环中，我们指定了一个模式：i 用于索引，\u0026amp;item 用于单个字节。因为 .iter().enumerate() 返回的是元素的引用，所以我们在模式中也使用了 \u0026amp;。\n在循环中，我们使用字节字面量 b' ' 来查找空格。如果找到了，就返回索引；否则，返回字符串的长度。\n现在我们有了第一个单词的索引，但这带来了一个新问题。这个 usize 类型的索引是独立于 \u0026amp;String 的，它的有效性无法得到保证。换句话说，它只是一个数字，但它所代表的上下文可能会发生改变。看下面这个例子：\n1 2 3 4 5 6 7 8 9 fn main() { let mut s = String::from(\u0026#34;hello world\u0026#34;); let word = first_word(\u0026amp;s); // 函数会返回5 s.clear(); // 这个方法会清空 s // 此时 word 的值仍然是5，但它已经毫无意义了，因为它指向的字符串已经被清空 } 这段代码可以正常编译。即使在调用 s.clear() 之后我们使用了 word，它也不会报错，因为 word 的值 5 和 s 的状态完全没有关联。如果我们尝试用 word 的值去提取 s 的第一个单词，就会出错，因为 s 的内容已经变了。\n不得不时刻担心 word 中的索引与 s 中的数据不同步，这既繁琐又容易出错。如果我们再写一个 second_word 函数，情况会变得更糟：\n1 fn second_word(s: \u0026amp;String) -\u0026gt; (usize, usize) { 现在我们需要跟踪一个起始索引和一个结束索引，这些值都是从特定数据计算出来的，但它们与原始数据又是独立的。我们有三组不相关的变量，必须确保它们始终保持同步。\n幸运的是，Rust 提供了字符串切片（string slices）来完美地解决这个问题。\n​\n4.3.1 字符串切片(string slice) 字符串切片是对 String 元素的一个连续序列的引用，看起来像这样：\n1 2 3 4 5 6 fn main() { let s = String::from(\u0026#34;hello world\u0026#34;); let hello = \u0026amp;s[0..5]; let world = \u0026amp;s[6..11]; } 切片不是对一整个字符串的引用，而是其的一部分。比如说“hello”在字符串中的切片就是从第 0 个字符到第 5 个字符，不包含第五个字符。所以它是 \u0026amp;s[0..5]。一个字符切片的格式就是你想要切片的字符串的引用加上 [start_index..end_index]，其中 start_index 是第一个字符的位置，而 end_index 是最后一个字符的后一个位置（因为 Rust 总是左开右闭）。在字符串切片的内部，存储着两个信息，第一是切片开始的位置，第二个是字符长度，通过 end_index 减去 start_index 得到。所以在 let world = \u0026amp;s[6..11] 之中的 world，就是一个包含一个指向 s 的第 6 个字符，并且长度为 5 的指针。具体如下图所示：\n在 Rust 的 .. 表达中，如果这个序列是从 0 开始的，那么 0 是可以省略，意味着下面两个表述是等价的：\n1 2 3 4 let s = String::from(\u0026#34;hello\u0026#34;); let slice = \u0026amp;s[0..2]; let slice = \u0026amp;s[..2]; 同样的，你可以两端都舍去来表达获取整个字符串的切片：\n1 2 3 4 5 6 let s = String::from(\u0026#34;hello\u0026#34;); let len = s.len(); let slice = \u0026amp;s[0..len]; let slice = \u0026amp;s[..]; [!NOTE]\n字符串切片的范围索引必须出现在有效的 UTF-8 字符边界上。如果你试图在多字节字符的中间创建一个字符串切片，你的程序将会以错误退出。\n有了以上的基础，我们来重新编写我们的 find_first_word 函数，我们可以通过返回一个字符串切片来找到第一个单词。其中字符串切片类型写做 \u0026amp;str：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 fn main() { let str = String::from(\u0026#34;hello world\u0026#34;); let first_word = find_first_word(\u0026amp;str); println!(\u0026#34;\\\u0026#34;{str}\\\u0026#34;`s first word is \\\u0026#39;{first_word}\\\u0026#39;\u0026#34;); //使用反斜杠\\来转译双引号 } fn find_first_word(s: \u0026amp;String) -\u0026gt; \u0026amp;str { let temp = s.as_bytes(); for (i, \u0026amp;iter) in temp.iter().enumerate() { if iter == b\u0026#39; \u0026#39; { return \u0026amp;s[..i]; //找到空格就返回字符串切片 } } return \u0026amp;s[..]; //未找到就返回整个字符串切片 } 现在当我们调用 find_first_word 时，我们会得到一个与字符串强相关的数据相关联的切片。这个切片由指向切片起点的引用和切片中的元素数量组成。\n同样，我们可以通过字符串切片来编写一个 find_second_word 函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 fn find_second_word(s: \u0026amp;String) -\u0026gt; \u0026amp;str { let temp = s.as_bytes(); let mut first_letter = 0; for (i, \u0026amp;iter) in temp.iter().enumerate() { if iter == b\u0026#39; \u0026#39; { if first_letter == 0 { first_letter = i + 1; //记录第一个空格的位置+1就是第二个单词的第一个字母 } else { return \u0026amp;s[first_letter..i]; //找到第二个空格 } } } return \u0026amp;s[..]; //未找到就返回整个字符串切片 } 我们现在拥有一个更简单的 API，因为编译器将确保 String 中的引用保持有效。还记得 之前程序中国的 bug 吗？当时我们得到了第一个单词的索引，但随后清除了字符串，导致索引无效？那段代码在逻辑上是不正确的，但并没有立即显示错误。如果我们继续尝试用清空后的字符串使用第一个单词的索引，问题会稍后显现。切片使这个 bug 不可能发生，并让我们能更快地发现代码中的问题。使用 find_first_word 的切片版本会在编译时抛出错误：\n1 2 3 4 5 6 7 fn main() { let mut s = String::from(\u0026#34;hello world\u0026#34;); let word = find_first_word(\u0026amp;s); s.clear(); //这里会报错 println!(\u0026#34;the first word is: {word}\u0026#34;); } 回想借用规则，如果我们对一个事物有不可变引用，我们就不能同时获取一个可变引用。因为 clear 需要截断 String ，它需要获取一个可变引用。调用 clear 后的 println! 使用 word 中的引用，所以在那一点上不可变引用必须仍然有效。Rust 禁止 clear 中的可变引用和 word 中的不可变引用同时存在，编译会失败。Rust 不仅使我们的 API 更容易使用，还在编译时消除了整类错误！\n回想我们之前讨论过字符串字面量存储在二进制文件中。现在我们已经了解了切片，可以正确理解字符串字面量：\n1 let s = \u0026#34;Hello, world!\u0026#34;; 这里的类型是 \u0026amp;str : 它是一个指向二进制中特定位置的切片。这也是为什么字符串字面量是不可变的； \u0026amp;str 是一个不可变引用。\n4.3.2 字符串切片作为函数入参 了解字符串切片之后，我们可以进一步修改我们的 find_first_word 函数。现在的函数声明可以是这样的：\n1 fn find_first_word(s:\u0026amp;str) -\u0026gt; \u0026amp;str{ 更有经验的 Rust 使用者 会编写上述的函数，因为它允许我们使用同一个函数处理 \u0026amp;String 值和 \u0026amp;str 值：当我们想要处理 \u0026amp;String 的时候，只需要使用 \u0026amp;s[..] 即可，或者我们可以直接写 \u0026amp;String，因为两者是等价的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 fn main() { let my_string = String::from(\u0026#34;hello world\u0026#34;); // `find_first_word` 可以处理String的部分切片 let word = find_first_word(\u0026amp;my_string[0..6]); // 也可以处理整个String的切片 let word = find_first_word(\u0026amp;my_string[..]); // 直接传递String的引用也可以，等价于整个String的切片 let word = find_first_word(\u0026amp;my_string); let my_string_literal = \u0026#34;hello world\u0026#34;; // `find_first_word` 同样可以处理字符串字面量的部分切片 let word = find_first_word(\u0026amp;my_string_literal[0..6]); // 也可以处理整个字符串字面量的切片 let word = find_first_word(\u0026amp;my_string_literal[..]); // 因为字符串字面量本身就是切片， // 所以也可以直接传递，不需要切片语法 let word = find_first_word(my_string_literal); } fn find_first_word(s: \u0026amp;str) -\u0026gt; \u0026amp;str { // 将字符串转换为字节数组 let bytes = s.as_bytes(); // 遍历字节数组 for (i, \u0026amp;item) in bytes.iter().enumerate() { // 如果遇到空格字节(b\u0026#39; \u0026#39;)，返回从开头到当前位置的切片 if item == b\u0026#39; \u0026#39; { return \u0026amp;s[0..i]; } } // 没有找到空格，返回整个字符串切片 return \u0026amp;s[..]; } 如果我们有一个字符串切片，可以直接传递。如果我们有一个 String ，可以传递 String 的切片或 String 的引用。这种灵活性利用了 deref 强制转换，这一特性我们将在第 15 章的“函数和方法中的隐式 deref 强制转换”部分进行介绍。\n4.3.3 其他切片 字符串切片，正如你所想象的那样，是专门针对字符串的。但还有一个更通用的切片类型。考虑这个数组：\n1 let a = [1,2,3,4,5]; 就和我们引用字符串一样，我们可能想要引用数组的一部分。我们会这样做：\n1 2 3 let a = [1, 2, 3, 4, 5]; let slice = \u0026amp;a[1..3]; assert_eq!(slice, \u0026amp;[2, 3]); 这个切片的类型是 \u0026amp;[i32] 。它和字符串切片一样工作，通过存储对第一个元素的引用和长度。你会用这种类型的切片来处理各种其他集合。当我们在第 8 章讨论向量时，我们会详细讨论这些集合。\nChapter 5：结构体(Structs) 结构体是一种自定义数据类型，它允许你将多个相关的值组合在一起并命名，这些值共同构成一个有意义的组。如果你熟悉 面向对象语言 ，结构体就像对象的数据属性。在本章中，我们将比较和对比元组和结构体，以扩展你已经掌握的知识，并展示何时使用结构体是组织数据更好的方式。\n5.1 定义和实例化结构体 与之前介绍过的元组很像，使用结构体可以让你把不同类型的变量聚集在一起。但是与元组不同的是，结构体要求你给每一个元素给一个命名，这个特性使得结构体可以更加灵活的引用元素，而不必像元组那样依照固定顺序。\n定义一个结构体，我们使用关键字 struct 加上这个结构体的名称，并用大括号将里面不同类型的元素给括起来，之后每个元素都要求有一个名称，并且必须显式声明这个元素的数据类型。具体如下所示：\n1 2 3 4 5 6 struct User { active: bool, username: String, email: String, sign_in_count: u64, } 在定义了结构体之后，要使用它，我们通过为每个字段指定具体值来创建该结构体的实例。我们通过声明结构体的名称，然后添加包含键值对的大括号来创建实例，其中键是字段的名称，值是我们想要存储在这些字段中的数据。我们不必按照在结构体中声明的顺序来指定字段。换句话说，结构体定义就像类型的通用模板，而实例用特定数据填充该模板来创建类型的值。如下所示：\n1 2 3 4 5 6 7 8 fn main() { let user1 = User { active: true, username: String::from(\u0026#34;someusername123\u0026#34;), email: String::from(\u0026#34;someone@example.com\u0026#34;), sign_in_count: 1, }; } 和 C 语言一样，我们使用 . 来引出一个结构体成员：\n1 2 3 4 5 6 7 8 9 10 fn main() { let mut user1 = User { active: true, username: String::from(\u0026#34;someusername123\u0026#34;), email: String::from(\u0026#34;someone@example.com\u0026#34;), sign_in_count: 1, }; user1.email = String::from(\u0026#34;anotheremail@example.com\u0026#34;); } 注意：在 Rust 中，我们只能控制整个结构体的可变性：我们不能要求某些部分是可变的，某些部分是不可变的，我们只能让整个实例是可变的或者不可变的。同样的，我们可以通过在函数中构建一个结构体然后返回出来：\n1 2 3 4 5 6 7 8 fn build_user(email: String, username: String) -\u0026gt; User { User { active: true, username: username, email: email, sign_in_count: 1, } } 给函数参数命名与结构体字段同名是合理的，但不得不重复 email 和 username 字段名和变量确实有点繁琐。如果结构体有更多字段，重复每个名称会更加令人烦恼。幸运的是，有一个方便的简写方式！\n5.1.2 元组结构体（Tuple Struct） Rust 中也允许结构体像元组那样创建，我们称之为元组结构体。元组结构体只有结构体名称提供的意义，但是没有与其元素关联的名称含义，因为它只提供了元素类型。当你想给整个元组命名，但是又想让他和其他元组成为不同的数据类型的时候，元组结构体十分好用；并且当你觉得常规结构体的结构体成员的命名过于复杂的时候，元组结构体也可以派上用场。\n要定义一个元组结构体，以 struct 关键字开始，然后是结构体名称，接着是元组中的类型。例如，这里我们定义并使用了两个名为 Color 和 Point 的元组结构体：\n1 2 3 4 5 6 7 struct Color(i32, i32, i32); struct Point(i32, i32, i32); fn main() { let black = Color(0, 0, 0); let origin = Point(0, 0, 0); } 虽然从结构体成员类型看上去 Color 和 Point 是相同的，但是它们任然是不同数据类型。因此，black 和 origin 也是两个不同类型的变量，因为他们是不同类型的实例。并且，如果一个函数的入参要求的数据类型是 Color，那么我们便不能传入 origin 作为其参数，因为 origin 的数据类型是 Point。与元组相同的是，我们也可以对元组结构体进行解构：\n1 let Point(x, y, z) = origin; 这样，我们就可以通过 origin.x 这样的方式引出结构体成员了。\n5.1.3 单元结构体（Unit-Like Struct）——无结构体成员的结构体 Rust 中可以定义没有任何结构体成员的结构体，我们称之为单元结构体，它与元组中的 unit 类型很像。当你需要在某个类型上实现一个 trait，但又不想在该类型中存储任何数据时，单元结构体就很有用。我们将在第 10 章讨论 trait。下面是一个声明并实例化名为 AlwaysEqual 的单元结构体的示例：\n1 2 3 4 5 struct AlwaysEqual; fn main() { let subject = AlwaysEqual; } 要定义 AlwaysEqual，我们使用 struct 关键字、结构体名称，然后加上一个分号。不需要大括号或圆括号！ 接着，我们可以用类似的方式在 subject 变量中获取 AlwaysEqual 的实例：直接使用定义的名字，不带任何大括号或圆括号。\n假设之后我们要为这个类型实现某种行为，使得 AlwaysEqual 的每个实例总是等于其他任何类型的实例（可能是为了测试目的而设定的固定结果）。我们不需要任何数据来实现这种行为！ 在第 10 章，你将学习如何定义 trait 并在任何类型（包括单元结构体）上实现它们。\n5.1.4 结构体的所有权 注意到在我们本章第一个例子的 User 结构体中，我们对其结构体成员的 username 和 email 都是使用的 String 类型，而不是一个 \u0026amp;str 类型。这是因为我们想要结构体拥有其所有成员的所有权，并且这些数据在该结构体的生命周期中始终有效。\n当然，我们也可以让结构体成员的数据类型是被其他对象拥有的数据类型的引用，但是实现这个点要求了一个 Rust 的中的概念——生命周期(lifetime)。这是一个后续会讨论的特性，在这里我们只需要知道，生命周期确保结构体引用的数据在其存在期间始终有效。假设你尝试在结构体中存储一个未指定生命周期的引用，就像下面这样；这是行不通的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 struct User { active: bool, username: \u0026amp;str, email: \u0026amp;str, sign_in_count: u64, } fn main() { let user1 = User { active: true, username: \u0026#34;someusername123\u0026#34;, email: \u0026#34;someone@example.com\u0026#34;, sign_in_count: 1, }; } 你会得到如下的报错：\n在第 10 章，我们将讨论如何修复这些错误，以便你可以在结构体中存储引用，但目前我们将使用类似于 String 的拥有类型来修复这些错误，而不是使用类似于 \u0026amp;str 的引用。\n5.2 使用结构体的编程 要了解我们何时可能需要使用结构体，让我们编写一个计算矩形面积的程序。我们将从使用单个变量开始，然后重构程序，直到使用结构体为止。\n让我们使用 Cargo 创建一个新的二进制项目，名为 rectangles，它将接收以像素为单位的矩形宽度和高度，并计算矩形的面积：\n1 2 3 4 5 6 7 8 9 fn main() { let width = 30f64; let height = 40f64; println!(\u0026#34;the area is {}\u0026#34;, calculate_area(width, height)); } fn calculate_area(width: f64, height: f64) -\u0026gt; f64 { width * height } 编译结果如下：\n这段代码通过调用 calculate_area 函数，使用每个维度来成功计算出矩形的面积，但我们还可以做更多来使这段代码更加清晰易读。\n函数 area 本应计算一个矩形的面积，但我们编写的函数有两个参数，而且程序中没有任何地方明确说明这两个参数之间的关系。将宽度和高度组合在一起会使代码更易读、更易于管理。\n5.2.2 使用元组重构 以下的程序使用的是元组来重构整个函数：\n1 2 3 4 5 6 7 8 fn main() { let rect1 = (30f64,40f64); println!(\u0026#34;the area is {}\u0026#34;, calculate_area(rect1)); } fn calculate_area(area:(f64,f64)) -\u0026gt; f64 { area.0 * area.1 } 在某种意义上，这个程序更好。元组让我们添加了一些结构，我们现在只传递一个参数。但在另一种意义上，这个版本更不清晰：元组不命名它们的元素，所以我们不得不索引到元组的各个部分，这使得我们的计算不那么明显。\n将宽度和高度混淆对于面积计算来说无关紧要，但如果我们要在屏幕上绘制矩形，这就很重要了！我们需要记住 width 是元组的索引 0 ，而 height 是元组的索引 1 。如果其他人要使用我们的代码，这会让他们更难弄清楚并记住。因为我们没有在我们的代码中传达数据的含义，所以现在更容易引入错误。\n5.2.3 使用结构体重构：增加更多意义 我们使用结构体来重构这个程序，通过给结构体成员的命名来优化程序。我们将元组修改成结构体：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 struct Rectangle { width: f64, height: f64, } fn main() { let rect1 = Rectangle { width: 30f64, height: 40f64, }; println!(\u0026#34;the area is {}\u0026#34;,calculate_area(\u0026amp;rect1)); } fn calculate_area(rect: \u0026amp;Rectangle) -\u0026gt; f64 { rect.height * rect.width } 在这里我们定义了一个结构体 Rectangle，其结构体成员是宽度 width，高度 height，他们的数据类型都是 f64。然后函数 calculate_area 的入参也是修改为 Rectangle 的引用，因为我们不需要修改其内容，只是简单的对其成员做一个乘法。\n现在，我们的长宽都是高度关联的，而不是像元组那样用 0、1 来表述。这对于清晰度来说是一个优势。\n5.2.4 派生特性 在调试程序时，能够打印出 Rectangle 的实例并查看其所有字段的值会很有用。但是直接使用 println! 是不行的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 struct Rectangle { width: f64, height: f64, } fn main() { let rect1 = Rectangle { width: 30f64, height: 50f64, }; println!(\u0026#34;rect1 is {rect1}\u0026#34;); } 会得到如下报错：\nprintln! 宏能够进行多种格式化操作，默认情况下，花括号会指示 println! 使用称为 Display 的格式化方式：这种输出形式是直接面向最终用户的。我们目前见过的原始类型都默认实现了 Display，因为你只会想用一种方式向用户展示 1 或其他原始类型的值。但对于结构体来说，println! 该如何格式化输出就不那么明确了，因为存在更多显示可能性：是否需要逗号？是否要打印花括号？所有字段都应该显示吗？由于这种不确定性，Rust 不会尝试猜测我们的意图，因此结构体没有提供默认的 Display 实现来配合 println! 和 {} 占位符使用。\n让我们试试看！现在 println! 宏调用会写成这样：println!(\u0026quot;rect1 is {rect1:?}\u0026quot;);。在花括号内加上 :? 标识符是告诉 println! 我们要使用名为 Debug 的输出格式。Debug trait 能让我们以对开发者友好的方式打印结构体，这样在调试代码时就能查看它的值了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 struct Rectangle { width: f64, height: f64, } fn main() { let rect1 = Rectangle { width: 30f64, height: 50f64, }; println!(\u0026#34;rect1 is {rect1:?}\u0026#34;);//使用了 :? } 编译后依旧报错：\n但是人性化的编译器提示我们：add #[derive(Debug)] to Rectangle or manually impl Debug for Rectangle。这是因为 Rust 本身不自带输出调试信息，我们需要手动显式的为我们的结构体开启这个功能——在结构体之前加上 #[derive(Debug)]：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #[derive(Debug)]//添加了这个 struct Rectangle { width: f64, height: f64, } fn main() { let rect1 = Rectangle { width: 30f64, height: 50f64, }; println!(\u0026#34;rect1 is {rect1:?}\u0026#34;); } 加上之后再次编译运行代码就会看到如下输出：\n太好了！虽然输出不是最美观的，但它显示了该实例中所有字段的值，这在调试时肯定会有帮助。当我们的结构体更复杂时，有一个更易于阅读的输出会很有用；在这种情况下，我们可以在 println! 字符串中使用 {:#?} 而不是 {:?} 。在这个例子中，使用 {:#?} 风格将输出以下内容：\n[!NOTE]\n如果有多个结构体需要使用这个派生功能，我们需要给每个你想要使用派生功能的结构体声明之前都加上 #[derive(Debug)]。\n使用 Debug 格式打印出值的另一种方法是使用 dbg! 宏，该宏会获取表达式的所有权（与 println! 不同，println! 获取的是引用），打印出 dbg! 宏在代码中调用位置所在的文件和行号，以及该表达式计算出的结果值，并返回该值的所有权。\n比如下列这个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #[derive(Debug)] struct Rectangle { width: f64, height: f64, } fn main() { let scale: f64 = 2f64; let rect1 = Rectangle { width: dbg!(30f64 * scale),//这里使用了 dbg! 返回表达式的所有权 height: 50f64, }; dbg!(\u0026amp;rect1);//这里使用了 dbg! } 我们可以将 dbg! 宏包裹在表达式 30f64 * scale 外围，由于 dbg! 会返回该表达式的值的所有权（即不影响原值传递），因此 width 字段最终获得的值就和没有调用 dbg! 时完全一样。在接下来的调用中，我们不希望 dbg! 获取 rect1 的所有权，所以传入的是 rect1 的引用。以下是这个示例的输出结果：\n从输出中可以看到，第一行内容来自 src/main.rs 第 10 行的调试输出，我们正在检查表达式 30f64 * scale 的计算过程，其结果值为 60.0（Rust 为整数/浮点数实现的 Debug 格式化输出会直接显示其数值）。src/main.rs 第 14 行的 dbg! 调用输出了 \u0026amp;rect1 的值，也就是 Rectangle 结构体的内容。这里的输出使用了 Rectangle 类型提供的格式化调试显示方式。当你需要弄清楚代码的实际执行过程时，dbg! 宏会非常有用！\n除了 Debug trait 外，Rust 还提供了许多可以通过派生（derive）属性来使用的 trait，它们能为我们的自定义类型添加实用功能。我们将在第 10 章探讨如何为这些 trait 实现自定义行为，以及如何创建你自己的 trait。Rust 中除了派生外还有许多其他属性，更多信息请参阅《Rust 参考手册》中的 \u0026ldquo;属性\u0026rdquo; 章节。\n我们当前的 calculate_area 函数功能非常特定化：它只能计算矩形的面积。如果能将这个行为与 Rectangle 结构体更紧密地绑定会更好，因为这个函数无法适用于其他类型。接下来我们将探讨如何通过把 calculate_area 函数改造成 Rectangle 类型的方法来继续重构这段代码。\n5.3 方法(Method) 方法和函数类似，都可以有入参、返回值，并且在内部也可以调用其他方法或者函数。但是与函数不同的是，方法是在结构体内部实现的，并且方法的第一个入参必须是 self，代表调用方法的结构体实例本身。\n5.3.1 定义一个方法 我们可以修改 calculate_area，让它成为一个方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 struct Rectangle { width: f64, height: f64, } impl Rectangle { fn calculate_area(\u0026amp;self) -\u0026gt; f64 { self.height * self.width } } fn main() { let rect1 = Rectangle { width: 30f64, height: 40f64, }; println!(\u0026#34;the area is {}\u0026#34;, rect1.calculate_area()); } 在这里，我们使用 impl（implementation）为结构体添加关联方法。具体做法是：在 impl 关键字后指定目标结构体名称（本例中是 Rectangle），然后在 {} 代码块内定义方法。我们将原来的 calculate_area 函数移植到这个实现块中，并将第一个参数改为 \u0026amp;self - 这样就成功将函数转换为 Rectangle 结构体的方法。调用时，和使用结构体字段一样，只需通过 . 运算符即可（例如 rect.calculate_area()），Rust 会自动将调用该方法的实例填入 self 参数。\n在 calculate_area 方法的原型中，我们使用 \u0026amp;self 替代了 rectangle: \u0026amp;Rectangle。这里的 \u0026amp;self 实际上是 self: \u0026amp;Self 的简写形式。在 impl 代码块内部，Self 类型就是该实现块对应类型的别名（本例中即 Rectangle）。按照 Rust 的约定，方法的第一个参数必须是一个名为 self 的 Self 类型参数，因此 Rust 允许我们在第一个参数位置直接简写为 self。需要注意的是，我们仍然需要在简写的 self 前添加 \u0026amp; 符号（即 \u0026amp;self），这表明该方法不可变地借用了 Self 实例（与我们之前使用 rectangle: \u0026amp;Rectangle 的意图一致）。方法可以通过以下三种方式处理 self 参数：获取所有权（直接使用 self）、不可变借用（如本例的 \u0026amp;self）、或者可变借用（\u0026amp;mut self）—— 这与处理其他常规参数的方式完全一致。\n使用方法而非函数的主要原因，除了提供更简洁的方法调用语法（不必在每个方法签名中重复声明 self 的类型）外，更在于代码的组织性。通过将所有针对类型实例的操作集中定义在同一个 impl 代码块中，我们避免了让后续使用我们代码的开发者在库的不同位置四处寻找 Rectangle 的功能实现。\n并且我们可以实现一个与结构体成员相同名字的方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 struct Rectangle { width: f64, height: f64, } impl Rectangle { fn width(\u0026amp;self)-\u0026gt; bool{ self.width \u0026gt; 0.0 } } fn main() { let rect1 = Rectangle { width: 30f64, height: 40f64, }; println!(\u0026#34;The rectangle has a nonzero width; it is {}\u0026#34;, rect1.width); } 运行结果如下：\n在这个实现中，我们定义当实例的 width 成员值大于 0 时，width 方法返回 true，值小于等于 0 时返回 false：这种同名方法可以自由访问同名成员，实现任意逻辑。在 main 函数中：\n当使用 rect1.width() 带括号形式时，Rust 明确识别这是调用 width 方法 当使用 rect1.width 无括号形式时，Rust 则自动识别为访问 width 成员 在 Rust 中，我们经常会（但并非总是）将方法命名为与字段同名，使其仅返回字段值而不进行其他操作。这类方法被称为 getter 方法。与其他语言不同，Rust 不会自动为结构体字段生成 getter，需要手动实现。这种设计主要有以下优势：\n访问控制：\n可以将字段设为私有(private)，同时将 getter 方法设为公开(public) 从而实现该字段的只读访问权限，作为类型公开 API 的一部分 封装性\n1 2 3 4 5 6 7 8 9 10 11 pub struct Rectangle { width: u32, // 私有字段 height: u32, // 私有字段 } impl Rectangle { // 公开的 getter 方法 pub fn width(\u0026amp;self) -\u0026gt; u32 { self.width } } 设计灵活性：\n即使后续修改内部数据结构，只要保持 getter 接口不变，就不会破坏外部代码 可以在 getter 中添加简单的验证逻辑或计算 关于公有(public)和私有(private)的具体概念，以及如何将字段或方法指定为公有/私有，我们将在第 7 章详细讨论。这种显式的访问控制是 Rust 封装性的重要体现，也是其安全保证的基础之一。\n[!TIP]\n-\u0026gt; 操作符去哪了？ 在 C 和 C++ 中，调用方法需要使用两个不同的操作符：\n直接调用对象方法时使用 . 调用对象指针的方法时使用 -\u0026gt;（需要先解引用指针） 换句话说，如果 object 是一个指针，object-\u0026gt;something() 就类似于 (*object).something()。\n而 Rust 没有与 -\u0026gt; 等效的操作符，取而代之的是 Rust 的 自动引用和解引用 功能。方法调用是 Rust 中少数几个具有这种行为的地方之一。\n工作原理 当你使用 object.something() 调用方法时，Rust 会自动添加 \u0026amp;、\u0026amp;mut 或 * 以使 object 与方法签名匹配。也就是说，以下两种写法是等价的：\n1 2 p1.distance(\u0026amp;p2); (\u0026amp;p1).distance(\u0026amp;p2); 显然第一种写法更加简洁。这种自动引用行为之所以能工作，是因为方法有明确的接收者——即 self 的类型。根据接收者和方法名，Rust 可以明确判断方法是在：\n读取数据（\u0026amp;self） 修改数据（\u0026amp;mut self） 还是获取所有权（self） Rust 将方法接收者的借用隐式化，这一特性在实践中大大提升了所有权的易用性。\n5.3.2 有多个入参的方法 现在，我们来实现另一个方法 can_hold，用于比较一个矩形是否能够容纳下另一个矩形，其本质就是比较两个矩形的面积：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 struct Rectangle { width: f64, height: f64, } impl Rectangle { fn calculate_area(\u0026amp;self) -\u0026gt; f64 { self.height * self.width } //判断是否能够容下的方法 fn can_hold(\u0026amp;self, another_rect: \u0026amp;Rectangle) -\u0026gt; bool { self.calculate_area() \u0026gt;= another_rect.calculate_area() } } fn main() { let rect1 = Rectangle { width: 20f64, height: 30f64, }; let rect2 = Rectangle { width: 30f64, height: 40f64, }; let rect3 = Rectangle { width: 5f64, height: 10f64, }; println!(\u0026#34;Can rect1({}) hold rect2({})? {}\u0026#34;,rect1.calculate_area(), rect2.calculate_area(),rect1.can_hold(\u0026amp;rect2)); println!(\u0026#34;Can rect1({}) hold rect3({})? {}\u0026#34;,rect1.calculate_area(), rect3.calculate_area(),rect1.can_hold(\u0026amp;rect3)); } 输出结果如下：\n我们知道要定义一个方法，因此它应该位于 impl Rectangle 代码块中。这个方法将被命名为 can_hold，它会以不可变借用的形式接收另一个 Rectangle 作为参数。通过观察调用该方法的代码 rect1.can_hold(\u0026amp;rect2)，我们可以确定参数类型：这里传入了 \u0026amp;rect2，即对 rect2 实例的不可变借用（rect2 是 Rectangle 的一个实例）。这样的设计是合理的，因为我们只需要读取 rect2 的数据（而不需要修改，否则就需要可变借用），同时我们希望 main 函数能保留 rect2 的所有权以便在调用 can_hold 方法后继续使用它。\ncan_hold 方法的返回值将是一个布尔值，其实现逻辑会分别检查当前矩形实例（self）的宽度和高度是否大于另一个 Rectangle 的宽度和高度。\n当然，Rust 并不要求我们将一个结构体的方法都写在一个 impl 代码块中，我们可以按照下面的形式将同一个结构体的不同方法都单独用一个代码块声明：\n1 2 3 4 5 6 7 8 9 10 11 impl Rectangle { fn area(\u0026amp;self) -\u0026gt; f64 { self.width * self.height } } impl Rectangle { fn can_hold(\u0026amp;self, other: \u0026amp;Rectangle) -\u0026gt; bool { self.width \u0026gt; other.width \u0026amp;\u0026amp; self.height \u0026gt; other.height } } 虽然这是可行的，但是我们仍然建议放在一起，因为这样集中化的处理会更有利于开发者管理结构体的方法。\n5.3.3 关联函数(Associated Functions) 所有在 impl 代码块中声明的函数都叫做关联函数，但是不是所有的关联函数都是方法。因为方法的第一个入参必须是 self 用来指定实例本身；但是我们依然可以定义一个入参不含有 self 的函数，因为他们并不需要操作具体的类型实例。我们之前已经使用过了像这样的函数 ： String 类型中的 String::from。\n在 Rust 中，不作为方法的关联函数常被用作构造器，用于返回结构体的新实例。这类函数通常被命名为 new，但要注意 new 并非语言内置关键字，只是一个约定俗成的命名惯例。例如，我们可以为 Rectangle 实现一个名为 square 的关联函数，它只需接收一个尺寸参数，并将该参数同时作为宽度和高度，从而更便捷地创建正方形矩形，而不需要重复指定相同的值两次：\n1 2 3 4 5 6 7 8 9 10 11 12 impl Rectangle { // 构造正方形的关联函数 fn square(size: f64) -\u0026gt; Self { Self { width: size, height: size, } } } // 使用示例 let sq = Rectangle::square(10.0); // 创建10x10的正方形 函数中的 Self 表示拥有这个关联函数的结构体的数据类型，在这个例子中就是 Rectangle。\n调用关联函数和调用其方法的运算符也是不同的，调用方法的运算符在前文我们已经使用了很多次了，是 .；但是调用一个关联函数我们使用的运算符是 ::，这类函数归属于结构体的命名空间：Rust 中的 :: 语法既用于关联函数，也用于模块创建的命名空间（我们将在第 7 章详细讨论模块系统）。\nChapter 6：枚举（Enums）和类型匹配（Pattern Matching） 结构体让你能够将相关的字段和数据组合在一起，比如一个 Rectangle 及其 width 和 height ，而枚举则让你能够表示一个值是可能值集合中的一个。例如，我们可能想要表示 Rectangle 是一组可能形状中的一个，这组形状还包括 Circle 和 Triangle 。为此，Rust 允许我们将这些可能性编码为一个枚举。\n让我们来看一个我们可能需要在代码中表达的情况，并了解为什么在这种情况下枚举比结构体更有用和更合适。比如说我们需要处理 IP 地址。目前，IP 地址使用两种主要标准：版本四和版本六。由于这些是我们程序可能遇到的 IP 地址的唯一可能性，我们可以枚举所有可能的变体，这也是枚举得名的由来。\n任何 IP 地址要么是版本四的地址，要么是版本六的地址，但不能同时是两者。IP 地址的这种特性使得枚举数据结构非常合适，因为枚举值只能是它的某个变体。版本四和版本六的 IP 地址本质上仍然是 IP 地址，所以在代码处理适用于任何类型 IP 地址的情况时，它们应该被视为同一类型。\n根据上述例子，我们可以构建一个名为 IpAddrVersion 的一个枚举类型：\n1 2 3 4 enum IpAddrVersion{ V4, V6, } 现在 IpAddrVersino 就是一个我们自定义的数据类型，我们可以在程序其他地方使用它！\n6.1 枚举值 在定义枚举类型之后，我们可以按照下列的方式定义其实例：\n1 2 3 4 fn main(){ let instance1 = IpAddrVersion::V4; let instance2 = IpAddrVersion::V6; } 同样，我们也可以定义一个入参为 IpAddrVersion 类型的函数：\n1 fn func(IpKind:IpAddrVersion){} 使用枚举的优势很多。再深入思考一下我们的 IP 地址类型，目前我们没有存储实际 IP 地址数据的方式；我们只知道它的类型。鉴于你在第 5 章刚刚学习了结构体，你可能会想用结构体来解决这个问题：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 enum IpAddrVersion{ V4, V6, } struct IpAddrKind{ veriosn:IpAddrVersion, addr:String, } fn main(){ let home = IpAddrKind{ veriosn:IpAddrVersion::V4, addr:String::from(\u0026#34;127.0.0.1\u0026#34;) }; let loopback = IpAddrKind{ veriosn:IpAddrVersion::V6, addr:String::from(\u0026#34;::1\u0026#34;) }; } 但是，与 C 语言的枚举不同，Rust 的枚举更加强大，我们甚至不需要定义一个结构体，而是只用一个枚举类型就可以做到这点：\n1 2 3 4 5 6 7 8 9 10 enum IpAddrKind{ V4(String), V6(String), } fn main(){ let home = IpAddrKind::V4(String::from(\u0026#34;127.0.0.1\u0026#34;)); let loopback = IpAddrKind::V6(String::from(\u0026#34;::1\u0026#34;)); } 在 Rust 中，枚举变量是可以添加值的，所以不需要额外的结构体来达到目的。同时，我们每定义一个变量，其本质都是使用了一个构造实例的函数。这里的 IpAddrKind::V4 本质是接收一个 String 类型的入参，然后返回一个 IpAddrKind 类型的变量的函数。\n同时，枚举中的所有成员的值不一定都要相同，我们可以给不同的枚举值不同的值：\n1 2 3 4 5 6 7 8 9 10 enum IpAddrKind{ V4(u8,u8,u8,u8), V6(String), } fn main(){ let home = IpAddrKind::V4(127,0,0,1); let loopback = IpAddrKind::V6(String::from(\u0026#34;::1\u0026#34;)); } 像这里我就让 V4 的值是 4 个 u8 类型的数据，而 V6 则是一个 String 类型的数据。\n上述我们通过了多种方式来定义 IP 地址信息，说明在程序中定义一个 IP 地址信息是一个很普遍的需求，所以 Rust 的标准库已经帮我们定义好了相关的数据类型，以下则是相关定义：\n1 2 3 4 5 6 7 8 9 10 11 12 struct Ipv4Addr { // something } struct Ipv6Addr { // something } enum IpAddr { V4(Ipv4Addr), V6(Ipv6Addr), } 可以看到，标准库中是事先定义好了两个结构体来存储不同版本的 IP 地址信息，然后通过一个枚举值来集中起来。同时这个例子我们也可以清楚的看见：我们能给枚举值的值中不仅仅可以存储基本的数字类型和字符串类型，还可以是我们自定义的结构体类型，甚至是另一个枚举类型！并且标准库中的数据类型不会比你将会遇见的类型复杂很多！\n请注意，尽管标准库中包含 IpAddr 的定义，但由于我们没有将标准库的定义引入当前作用域，我们仍然可以创建和使用自己的定义而不会产生冲突。我们将在第 7 章中更详细地讨论如何将类型引入作用域。\n接下来看下面这个例子：\n1 2 3 4 5 6 enum Message { Quit, Move { x: i32, y: i32 }, Write(String), ChangeColor(i32, i32, i32), } 这个枚举类型有四个成员：\nQuit：没有任何值 Move：其有两个有名字的值 Write：有一个无名的值 CangeColor：有三个无名的值 这样的定义有点类似于结构体：\n1 2 3 4 5 6 7 struct QuitMessage; // unit类型 struct MoveMessage { x: i32, y: i32, } struct WriteMessage(String); // 元组结构体 struct ChangeColorMessage(i32, i32, i32); // 元组结构体 但是与结构体不同的是，枚举把所有的这些变体都归为一个数据类型。并且这样使用结构体定义不同的变体会让我们函数的入参成为一个大麻烦：我们很难处理入参都是不同的数据类型，在这点上，使用一个枚举值将会有很大的好处。\n与结构体中的方法一样，我们可以使用 impl 关键字来为枚举定义其方法。比如下列我们就给 Message 定义了一个名为 call 的方法：\n1 2 3 4 5 6 7 8 9 10 impl Message { fn call(\u0026amp;self) { // something } } fn main(){ let m = Message::Write(String::from(\u0026#34;hello\u0026#34;)); m.call(); } 方法体将使用 self 获取我们调用了方法的对象的值。在这个例子中，我们创建了一个名为 m 的变量，其值为 Message::Write(String::from(\u0026quot;hello\u0026quot;)) ，当 m.call() 运行时， self 将是 call 方法体中的值。\n6.1.2 选项枚举（Option） Optin 是标准库定义的一个枚举。它可以有一个值，也可以没有。例如，如果你请求一个非空列表中的第一个元素，你会得到一个值。如果你请求一个空列表中的第一个元素，你会什么也得不到：这意味着编译器可以检查你是否处理了所有应该处理的情形；这项功能可以防止在其他编程语言中极为常见的错误。\n编程语言的设计常常被认为取决于包含哪些特性，但刻意排除的特性同样重要。Rust 就没有许多其他语言中常见的 null 功能。Null 是一个表示“无值”的值。在支持 null 的语言中，变量总是处于两种状态之一：null 或 非 null。\n但是 null 会导致很多隐藏的问题：\n1 2 String str = null; int length = str.length(); // 抛出 NullPointerException 开发者必须要手动检查一下当前的这个值是不是空值：if(str != null)，但是编译器通常不会强制要求你这么做，所以很容易遗漏。\n因此，Rust 不提供 null，但是标准库提供了一种枚举值来表示一个值是否为空值。如下是标准库中 Option\u0026lt;T\u0026gt; 的定义：\n1 2 3 4 enum Option\u0026lt;T\u0026gt; { None, Some(T), } 由于这个枚举过于常用，所以它被 prelude 包含，意味着我们不需要显式将其带入作用域。它的变体也直接被 prelude 包含，所以我们可以直接使用 Some(T) 和 None 而不必使用 Option:: 的前缀。这种情况下，Option\u0026lt;T\u0026gt; 依旧也是一种普通的枚举，并且 Some(T) 和 None 也依然是其变体。\n其中 \u0026lt;T\u0026gt; 是我们还没学习过的语法。它是泛型类型(generic)参数，我们将在第 10 章更详细地介绍泛型。需要知道的是， \u0026lt;T\u0026gt; 表示 Some 枚举的 Option 变体可以容纳任意类型的单个数据，而每次用具体类型替换 T 时，都会使整体 Option\u0026lt;T\u0026gt; 类型变为不同的类型。以下是一些使用 Option 值来容纳数值类型和字符类型的示例：\n1 2 3 4 5 fn main() { let some_number = Some(5); let some_char = Some(\u0026#39;e\u0026#39;); let absent_number: Option\u0026lt;i32\u0026gt; = None; } some_number 的类型是 Option\u0026lt;i32\u0026gt; 。 some_char 的类型是 Option\u0026lt;char\u0026gt; ，这是一个不同的类型。Rust 可以推断这些类型，因为我们已经在 Some 变体中指定了一个值。对于 absent_number ，Rust 要求我们标注整体的 Option 类型：编译器不能仅通过查看一个 None 值来推断对应的 Some 变体将持有哪种类型。在这里，我们告诉 Rust，我们希望 absent_number 是 Option\u0026lt;i32\u0026gt; 类型。\n当我们拥有一个 Some 值时，我们知道存在一个值，并且该值被包含在 Some 中。当我们拥有一个 None 值时，从某种意义上说，它和 null 意思相同：我们没有有效的值。那么，拥有 Option\u0026lt;T\u0026gt; 比拥有 null 好在哪里呢？\n简而言之，因为 Option\u0026lt;T\u0026gt; 和 T （其中 T 可以是任何类型）是不同的类型，编译器不会让我们将一个 Option\u0026lt;T\u0026gt; 值当作一个确定有效的值来使用。例如，这段代码不会编译，因为它试图将一个 i8 加到一个 Option\u0026lt;i8\u0026gt; 上：\n1 2 3 4 5 6 fn main() { let x: i8 = 5; let y: Option\u0026lt;i8\u0026gt; = Some(5); let sum = x + y; } 运行这段代码的报错如下：\n换句话说，你必须先将 Option\u0026lt;T\u0026gt; 转换成 T 类型，才能对其执行 T 类型的操作。这种设计从根本上解决了 null 最常见的陷阱——当某个值实际为 null 时，开发者却误以为它非空。\n通过显式要求可能为空的值必须声明为 Option\u0026lt;T\u0026gt; 类型，Rust 帮助你避免错误假设值非空的情况，从而让你对代码更有信心。当你需要使用可能为空的值时，必须通过将该值的类型设为 Option\u0026lt;T\u0026gt; 来明确表明这一点。在使用这个值时，你必须显式处理值为空的情况。而对于那些类型不是 Option\u0026lt;T\u0026gt; 的值，你可以安全地认为它们绝不会为空。这是 Rust 为了限制空值的普遍性并提高代码安全性而做出的深思熟虑的设计决策。\n那么当你有一个 Option\u0026lt;T\u0026gt; 类型的值时，如何从 Some 变体中取出 T 值以便使用呢？Option\u0026lt;T\u0026gt; 枚举提供了大量适用于各种场景的方法，你可以在其 [文档](Option in std::option - Rust)中查阅。熟悉 Option\u0026lt;T\u0026gt; 的各种方法对你学习 Rust 将会非常有帮助。\n通常来说，要使用一个 Option\u0026lt;T\u0026gt; 值，你需要编写能处理每种变体的代码。当值为 Some(T) 时执行某段代码（该代码可以使用内部的 T 值），而当值为 None 时则执行另一段代码（此时没有 T 值可用）。match 表达式正是用于处理枚举的控制流结构：它会根据枚举的具体变体执行不同的代码分支，且这些分支可以访问匹配值内部的数据。\n6.2 match——流控制结构 Rust 有一个极其强大的控制流结构叫 match，它允许你将值与一系列模式进行比较，然后根据匹配到的模式执行对应代码。模式可以由字面值、变量名、通配符和其他多种内容构成；第 19 章会详细介绍所有不同的模式及其用途。match 的强大之处在于其模式的表现力，以及编译器会确保所有可能的情况都得到处理这一事实。\n将 match 表达式想象成一个硬币分拣机：硬币沿着带有不同尺寸孔洞的轨道滑下，每个硬币会穿过它遇到的第一个能容纳它的孔洞。同样地，值会依次通过 match 中的每个模式，当值在第一个匹配的模式中“契合”时，它就会进入相应的代码块，在执行过程中被使用。\n说到硬币，让我们用 match 作为例子！我们可以编写一个函数，它接受一个未知的硬币，并以与计数机类似的方式确定它是哪种硬币，并返回其以分为单位的值：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 enum Coin { Penny, //1美分 Nickel, //5美分 Dime, //10美分 Quarter, //25美分 } fn value_in_cents(coin: Coin) -\u0026gt; f64 { match coin { Coin::Penny =\u0026gt; 0.01, Coin::Nickel =\u0026gt; 0.05, Coin::Dime =\u0026gt; 0.1, Coin::Quarter =\u0026gt; 0.25, } } fn main(){ let temp = Coin::Penny; println!(\u0026#34;is {}$\u0026#34;,value_in_cents(temp)); } 让我们拆解这个 value_in_cents 函数中的 match 表达式。首先我们列出 match 关键字，后跟一个表达式（本例中是 coin 值）。这看起来与 if 使用的条件表达式非常相似，但有个重要区别：if 的条件必须求值为布尔值，而这里的表达式可以是任何类型。本例中 coin 的类型是我们第一行定义的 Coin 枚举。\n接下来是匹配分支（arms）。每个分支有两部分：一个模式和一些代码。第一个分支的模式是值 Coin::Penny，然后是用 =\u0026gt; 运算符分隔的模式和要运行的代码。这里的代码就是简单的值 1。每个分支之间用逗号分隔。\n当 match 表达式执行时，它会按顺序将结果值与每个分支的模式进行比较。如果模式匹配值，则执行与该模式关联的代码。如果模式不匹配，则继续执行下一个分支，就像硬币分拣机一样。我们可以根据需要设置任意数量的分支：在示例中，我们的 match 有四个分支。\n每个分支关联的代码都是一个表达式，匹配分支中表达式的返回值就是整个 match 表达式的返回值。\n如果匹配分支的代码很短（如示例 6-3 中每个分支只是返回一个值），我们通常不使用大括号。如果想在匹配分支中运行多行代码，则必须使用大括号，此时分支后的逗号是可选的。例如，以下代码在每次用 Coin::Penny 调用方法时都会打印 \u0026ldquo;Lucky penny!\u0026quot;，但仍然会返回代码块的最后一个值 1：\n1 2 3 4 5 6 7 8 9 10 11 fn value_in_cents(coin: Coin) -\u0026gt; f64 { match coin { Coin::Penny =\u0026gt; { println!(\u0026#34;Lucky penny!\u0026#34;); 0.01 } Coin::Nickel =\u0026gt; 0.05, Coin::Dime =\u0026gt;0.1, Coin::Quarter =\u0026gt; 0.25, } } 6.2.2 绑定值的匹配值 match 匹配分支的另一个实用特性是：它们可以绑定到与模式匹配的值部分。这让我们能够从枚举变体中提取值。\n举个例子，我们修改其中一个枚举变体，使其内部包含数据。在 1999 年至 2008 年间，美国铸币局发行了背面印有 50 个州不同设计的 25 美分硬币。其他硬币没有这种特殊设计，只有 25 美分硬币有这个额外值。我们可以通过修改 Quarter 变体来包含一个内部的 UsState 值，如示例：\n1 2 3 4 5 6 7 8 9 10 11 12 enum UsState { Alabama, Alaska, // .. } enum Coin { Penny, //1美分 Nickel, //5美分 Dime, //10美分 Quarter(UsState), //25美分 } 假设我们有个朋友正在收集全美 50 州的纪念币。当我们按硬币类型整理零钱时，还会特别报出每个 25 美分硬币对应的州名——这样如果遇到朋友尚未收藏的款式，他们就可以将其收入囊中。\n在这段代码的 match 表达式中，我们为匹配 Coin::Quarter 变体的模式添加了一个名为 state 的变量。当匹配到 Coin::Quarter 时，state 变量会自动绑定到该硬币对应的州值。这样我们就可以在该分支的代码中使用这个 state 值，具体实现如下：\n1 2 3 4 5 6 7 8 9 10 11 fn value_in_cents(coin: Coin) -\u0026gt; f64 { match coin { Coin::Penny =\u0026gt; 0.01, Coin::Nickel =\u0026gt; 0.05, Coin::Dime =\u0026gt; 0.1, Coin::Quarter(state) =\u0026gt;{ println!(\u0026#34;State quarter from {state:?}!\u0026#34;); 0.25 } } } 当我们调用 value_in_cents(Coin::Quarter(UsState::Alaska)) 时，coin 的值会是 Coin::Quarter(UsState::Alaska)。当我们将这个值与每个匹配分支进行比较时，在到达 Coin::Quarter(state) 之前都不会匹配成功。此时，state 将会绑定到值 UsState::Alaska。接着我们就可以在 println! 表达式中使用这个绑定，从而从 Quarter 这个枚举变体中获取到内部的州值。\n6.2.3 与 Option\u0026lt;T\u0026gt; 类型匹配 在上一节中，我们希望在使用 Option\u0026lt;T\u0026gt; 时从 Some 中获取 T 的值；我们也可以使用 match 处理 Option\u0026lt;T\u0026gt; ，就像我们处理 Coin 枚举一样！我们不再比较硬币，而是比较 Option\u0026lt;T\u0026gt; 的变体，但 match 表达式的工作方式保持不变。\n接下来我们写一个函数接收 Option\u0026lt;i32\u0026gt; 类型的值，如果有值，则在原来值的基础上加一，如果没有，就返回其本身回去。\n1 2 3 4 5 6 7 8 9 10 11 12 fn plus_one(var: Option\u0026lt;i32\u0026gt;) -\u0026gt; Option\u0026lt;i32\u0026gt; { match var { None =\u0026gt; None, Some(Num) =\u0026gt; Some(Num + 1), } } fn main() { let five = Some(5); let six = plus_one(five); let none = plus_one(None); } 当我们调用 plus_one(five) 的时候，var 的值就是 Some(5)，与 None =\u0026gt; None, 分支不匹配所以会直接跳过这个分支，去匹配下面的分支。之后发现与 Some(Num) =\u0026gt; Some(Num + 1), 匹配，所以会执行该分支的代码。\n将 match 和枚举结合使用在很多场景下都非常实用。你会在 Rust 代码中频繁看到这种模式：对一个枚举进行 match 匹配，将变量绑定到内部数据，然后基于此执行相应代码。刚开始可能有点难以掌握，但一旦习惯后，你会希望所有语言都有这个特性。这一直是最受用户喜爱的功能之一。\n来看这下面的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 fn plus_one(x: Option\u0026lt;i32\u0026gt;) -\u0026gt; Option\u0026lt;i32\u0026gt; { match x { Some(i) =\u0026gt; Some(i + 1), //缺少None分支 } } fn main() { let five = Some(5); let six = plus_one(five); let none = plus_one(None); } 编译运行会发现如下报错：\n我们没有处理 None 分支，存在潜在威胁，所以编译器向我们报错了。\nRust 的编译器知道我们没有覆盖所有可能的情况，甚至能精确指出我们遗漏了哪个模式！Rust 中的匹配是穷尽式的：我们必须涵盖所有可能性，代码才能通过编译。特别是在处理 Option\u0026lt;T\u0026gt; 时，当 Rust 阻止我们忘记显式处理 None 的情况时，它实际上保护我们免于在可能为 null 的情况下错误假定值一定存在——从而彻底避免了 null 值匹配的情况。\n6.2.4. 全模式匹配与 _ 占位符 在使用枚举时，我们可以针对少数特定值执行特殊操作，而对其他所有值执行默认操作。假设我们正在实现一个游戏：如果你掷出 3 点，你的玩家不会移动，而是获得一顶新潮帽子；如果掷出 7 点，你的玩家会失去一顶潮帽；对于其他所有数值，你的玩家将在游戏板上移动相应数量的格子。以下是一个实现该逻辑的 match 示例（其中骰子结果是硬编码值而非随机数，其他逻辑用空函数表示，因为具体实现超出本例范围）：\n1 2 3 4 5 6 7 8 9 10 11 12 fn add_fancy_hat() {} fn remove_fancy_hat() {} fn move_player(num_spaces: u8) {} fn main() { let dice_roll = 9; match dice_roll { 3 =\u0026gt; add_fancy_hat(), 7 =\u0026gt; remove_fancy_hat(), other =\u0026gt; move_player(other), } } 对于前两个分支，其模式直接匹配字面值 3 和 7。最后一个分支覆盖所有其他可能的值，模式为我们命名为 other 的变量。该分支运行的代码通过将变量传递给 move_player 函数来使用它。\n这段代码能够编译通过，尽管我们并未列出所有可能的 u8 类型值，因为最后一个模式会匹配所有未被明确列出的值。这种通配模式（catch-all pattern）确保了 match 表达式的穷尽性要求。需要注意的是，我们必须将通配分支放在最后，因为模式是按顺序匹配的。如果将通配分支放在前面，后面的分支就永远不会被执行——因此，如果在通配分支之后添加其他分支，Rust 会发出警告！\nRust 还提供了一种在需要通配匹配但又不使用该值时的特殊模式：_。这个下划线模式会匹配任何值，但不会绑定到该值。这相当于告诉 Rust 我们不会使用这个值，因此 Rust 不会提示存在未使用的变量。\n现在假设我们修改游戏规则：如果掷出的数字不是 3 或 7，就必须重新掷骰子。此时我们不再需要使用通配值，因此可以将代码中的 other 变量改为 _：\n1 2 3 4 5 6 7 8 9 10 11 12 fn add_fancy_hat() {} fn remove_fancy_hat() {} fn reroll() {} fn main() { let dice_roll = 9; match dice_roll { 3 =\u0026gt; add_fancy_hat(), 7 =\u0026gt; remove_fancy_hat(), _ =\u0026gt; reroll(), } } 这个例子也达到了 match 的穷尽性要求，并且由于我们不需要使用这个值，我们使用 _ 来避免编译器警告。\n最后，我们将游戏规则再修改一次，以便如果你掷出的不是 3 或 7，你的回合中就不会发生任何其他事情。我们可以通过将 unit 类型作为与 _ 分支对应的代码来表示这一点：\n1 2 3 4 5 6 7 8 9 10 11 fn add_fancy_hat() {} fn remove_fancy_hat() {} fn main() { let dice_roll = 9; match dice_roll { 3 =\u0026gt; add_fancy_hat(), 7 =\u0026gt; remove_fancy_hat(), _ =\u0026gt; (), } } 这样，我们就告诉编译器我们不需要使用它的值，并且它对应的分支上不需要做任何操作。\n6.3 使用 if let 和 let else 实现更简洁的流控制 if let 语法让你能将 if 和 let 结合成一种更简洁的方式来处理匹配某个模式而忽略其余部分的情况。如下列代码，它匹配 config_max 变量中的 Option\u0026lt;u8\u0026gt; 值，但只想在值是 Some 变体时执行代码。\n1 2 3 4 5 6 7 fn main() { let config_max = Some(3u8); match config_max { Some(max) =\u0026gt; println!(\u0026#34;The maximum is configured to be {max}\u0026#34;), _ =\u0026gt; (), } } 如果值是 Some ，我们通过在分支中将值绑定到变量 max 来打印出 Some 变体中的值。我们不想对 None 值做任何操作。为了满足 match 表达式，我们必须在处理完一个变体后添加 _ =\u0026gt; () ，这很烦人，需要添加冗余代码。\n对于这种情况，我们可以使用 if let 来简化这个流程：\n1 2 3 4 5 6 fn main() { let config_max = Some(3u8); if let Some(max) = config_max { println!(\u0026#34;The maximum is configured to be {max}\u0026#34;); } } if let 的语法采用等号分隔的模式和表达式。它的工作方式与 match 相同：表达式会被传入 match，而模式则作为第一个匹配分支。在这个例子中，模式是 Some(max)，max 会绑定到 Some 内部的值。然后我们就可以在 if let 代码块中使用 max，就像在对应的 match 分支中使用 max 一样。只有当值匹配该模式时，才会执行 if let 代码块中的代码。\n使用 if let 意味着更少的代码、更少的缩进和更少的样板代码。但这样做的代价是失去了 match 强制执行的穷尽性检查——这种检查能确保你不会遗漏处理任何情况。选择使用 match 还是 if let 取决于你当前的具体需求，以及为了代码简洁性而放弃穷尽性检查是否值得。\n换句话说，你可以把 if let 看作是一种语法，它对应的是仅匹配单个模式并忽略其他所有值的 match 表达式。\n我们还可以为 if let 添加一个 else 分支。这个 else 代码块的作用等同于与 if let + else 等价的 match 表达式中的 _ 分支。回想一下之前的 Coin 枚举定义，其 Quarter 变体还包含一个 UsState 值。如果我们想在统计所有非 25 美分硬币的同时，还要报告 25 美分硬币所属的州，我们可以这样使用 match 表达式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #[derive(Debug)] enum UsState { Alabama, Alaska, // ... } enum Coin { Penny, Nickel, Dime, Quarter(UsState), } fn main() { let coin = Coin::Penny; let mut count = 0; match coin { Coin::Quarter(state) =\u0026gt; println!(\u0026#34;State quarter from {state:?}!\u0026#34;), _ =\u0026gt; count += 1, } } 或者我们可以使用 if let 和 else 来修改这个代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #[derive(Debug)] enum UsState { Alabama, Alaska, // ... } enum Coin { Penny, Nickel, Dime, Quarter(UsState), } fn main() { let coin = Coin::Penny; let mut count = 0; if let Coin::Quarter(state) = coin { println!(\u0026#34;State quarter from {state:?}!\u0026#34;); } else { count += 1; } } 常见的模式是：当值存在时执行某些计算，否则返回一个默认值。继续以带有 UsState 值的硬币为例，如果我们想根据硬币上刻印的州的历史年代说些有趣的话，可以给 UsState 添加一个方法来检查该州的 \u0026ldquo;年龄\u0026rdquo;，比如这样：\n1 2 3 4 5 6 7 8 9 impl UsState { fn existed_in(\u0026amp;self, year: u16) -\u0026gt; bool { match self { UsState::Alabama =\u0026gt; year \u0026gt;= 1819, UsState::Alaska =\u0026gt; year \u0026gt;= 1959, // ... } } } 通过在内部引入一个 state 变量结合 if let 语句去匹配硬币的类型：\n1 2 3 4 5 6 7 8 9 10 11 fn describe_state_quarter(coin: Coin) -\u0026gt; Option\u0026lt;String\u0026gt; { if let Coin::Quarter(state) = coin { if state.existed_in(1900) { Some(format!(\u0026#34;{state:?} is pretty old, for America!\u0026#34;)) } else { Some(format!(\u0026#34;{state:?} is relatively new.\u0026#34;)) } } else { None } } 虽然这样能完成任务，但它把所有逻辑都塞进了 if let 语句的代码块里。如果要处理的逻辑更复杂，就很难一眼看出顶层分支之间的关系了。我们其实可以利用表达式会产生值这个特性——既可以通过 if let 获取州信息，也可以直接提前返回，如下所示（用 match 也能实现类似效果）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 fn describe_state_quarter(coin: Coin) -\u0026gt; Option\u0026lt;String\u0026gt; { let state = if let Coin::Quarter(state) = coin { state } else { return None; }; if state.existed_in(1900) { Some(format!(\u0026#34;{state:?} is pretty old, for America!\u0026#34;)) } else { Some(format!(\u0026#34;{state:?} is relatively new.\u0026#34;)) } } 不过这种方式也有点让人头疼！if let 的一个分支会产生一个值，而另一个分支则会直接终止函数并返回。\n为了让这种常见模式表达得更优雅，Rust 提供了 let...else 语法。let...else 的语法结构和 if let 非常相似：左侧是模式，右侧是表达式。但不同之处在于它没有 if 分支，只有 else 分支。如果模式匹配成功，就会在当前作用域中绑定模式匹配的值；如果匹配失败，程序就会进入 else 分支，而该分支必须通过返回（或其他方式）终止当前控制流：\n1 2 3 4 5 6 7 8 9 10 11 fn describe_state_quarter(coin: Coin) -\u0026gt; Option\u0026lt;String\u0026gt; { let Coin::Quarter(state) = coin else { return None; }; if state.existed_in(1900) { Some(format!(\u0026#34;{state:?} is pretty old, for America!\u0026#34;)) } else { Some(format!(\u0026#34;{state:?} is relatively new.\u0026#34;)) } } 可以看到，这种方式让代码始终保持在函数的 \u0026ldquo;主逻辑路径\u0026rdquo; 上，不会像 if let 那样因为两个分支产生显著不同的控制流。\n当你遇到用 match 表达会显得过于冗长的逻辑时，请记住你的 Rust 工具箱里还有 if let 和 let...else 这两个利器。\nChapter 7 项目管理 随着程序规模的增长，代码组织会变得越来越重要。通过将相关功能分组并用清晰的特征分隔代码，你能更明确地找到实现特定功能的代码位置，以及修改功能行为的入口。\n目前我们编写的程序都位于单个文件的单一模块中。当项目增长时，应当通过将代码拆分为多个模块、再分散到多个文件中来组织代码结构。一个包（package）可以包含多个二进制箱（crate），以及可选的一个库箱。当包继续扩展时，你可以将部分代码提取为独立的箱，使其成为外部依赖项。本章将涵盖所有这些技术。对于由多个相互关联且协同演进的包组成的大型项目，Cargo 提供了工作区（workspace）功能，我们将在第 14 章 \u0026quot; Cargo 工作区\u0026rdquo; 中讨论。\n我们还将讨论封装实现细节——这能让你在更高层次复用代码：一旦实现了某个操作，其他代码只需通过公开接口调用，而无需了解内部实现逻辑。通过代码设计，你可以明确哪些部分是对外公开的，哪些是保留修改权的私有实现细节。这也是减少心智负担的重要方式。\n另一个相关概念是作用域（scope）：代码所处的嵌套上下文会定义一组 \u0026ldquo;在作用域内\u0026rdquo; 的名称。在编写、阅读和编译代码时，程序员和编译器都需要知道特定位置的名称是指变量、函数、结构体、枚举、模块、常量还是其他项，并理解其含义。你可以创建作用域并控制名称的可见性。同一作用域内不允许存在同名项，但可通过工具解决命名冲突。\nRust 提供了一系列管理代码组织的功能，包括控制细节的公开/私有性以及程序中各作用域的命名。这些功能被统称为模块系统，主要包括：\n包（Packages）：Cargo 提供的构建、测试和共享箱的功能 箱（Crates）：生成库或可执行文件的模块树 模块与 use 关键字：控制路径的组织、作用域和私有性 路径（Paths）：命名结构体、函数或模块等项的方式 本章将详解这些功能及其协作方式，并阐述如何利用它们管理作用域。学完后，你将建立起对模块系统的完整认知，并能像专家一样驾驭作用域！\n7.1 模块(Moudel) 模块化编程一直都是编程中很重要的概念，Rust 中使用了 mod 来定义一个外部可调用的模块，我们可以使用 pub 关键字来让我们想要其他文件可调用的部分变为外部可调用；我们可以通过 use 来引用我们自己的模块或者其他人写好的模块；使用一个模块内的接口要通过路径(path)使用 :: 来引出我们要使用的部分。\nRust 的模块系统通过 mod 和 pub 关键字实现了灵活的代码组织。根 crate 通常是 main.rs（二进制入口）或 lib.rs（库核心），但也可以通过 src/bin/ 放置多个二进制 crate。对于复杂项目，建议在 lib.rs 中声明所有模块并通过单独文件实现具体逻辑，main.rs 仅作调用入口，这种分离提升了代码复用性和编译效率。\n模块声明方式有两种：在根文件中用 mod name; 声明并拆分到同名文件（如 name.rs），或直接用 mod name { ... } 内联实现。简单逻辑适合内联，复杂模块建议拆分为文件。跨模块访问需双重公开：既要用 pub mod 声明模块公开，又要用 pub 标记模块内需要暴露的项（函数/类型等），否则默认私有。例如 pub mod utils 配合 pub fn helper() 才能被其他文件通过 crate::utils::helper 调用。\nuse 关键字可简化长路径，而文件模块的物理结构（如 src/a/b.rs）需与逻辑路径（crate::a::b）匹配。这种设计既保证了代码组织的清晰度，又通过严格的可见性控制（pub 层级）维护了封装性，适应从脚本到大型项目的各种场景。\n这里，我们创建了一个名为 backyard 的二进制 crate，以说明这些规则。crate 的目录，也名为 backyard ，包含这些文件和目录：\n1 2 3 4 5 6 7 8 backyard ├── Cargo.lock ├── Cargo.toml └── src ├── garden │ └── vegetables.rs ├── garden.rs └── main.rs 这个情况下的 crate 根文件是 src/main.rs，它包含：\n1 2 3 4 5 6 7 8 use crate::garden::vegetables::Asparagus; pub mod garden; fn main() { let plant = Asparagus {}; println!(\u0026#34;I\u0026#39;m growing {plant:?}!\u0026#34;); } pub mod garden; 告诉编译器要引入从 src/garden.rs 中找到的代码：\n1 pub mod vegetables; 这里 pub mod vegetables; 又会让编译器去寻找 src/garden/vegetables.rs 中的代码，然后包含它：\n1 2 #[derive(Debug)] pub struct Asparagus {} 7.1.2 将相关的代码包含到一个模块中 模块(moudel)让我们很好的组织我们的代码，让代码可读性和复用性更好。并且模块让我们控制模块的隐私性，因为除非使用 pub 显式声明，一个模块默认是不可外部调用的；但是一旦使用了 pub 声明模块，则该模块就是外部可调用的。\n接下来我们来编写一个例子，我们会写一个提供餐厅各种功能的 crate；我们只攥写函数名，但是将函数内部空出来，因为具体实现与我们例子关系不大。\n在餐饮行业，餐厅的某些区域被称为前厅，而另一些区域则被称为后厨。前厅是顾客所在的地方；这包括接待员安排顾客就座、服务员点单和收款，以及调酒师调制饮品。后厨是厨师和厨师在厨房工作、洗碗工清洁以及经理处理行政工作的地方。\n要按这种方式组织我们的 crates，我们可以将它的函数组织成嵌套模块。通过运行 cargo new restaurant --lib 创建一个名为 restaurant 的新库。\n1 2 3 4 5 6 7 8 9 10 11 12 mod front_of_house{//前厅 mod hosting{//接待 fn add_to_waitlist(){} fn seat_at_table(){} } mod serving{//服务 fn take_oder(){} fn serve_oder(){} fn take_payment(){} } } 我们使用 mod 关键字定义模块，后跟模块名称（本例中为 front_of_house）。模块体则位于大括号内。模块内部可以嵌套其他模块，如本例中的 hosting 和 serving 模块。模块还能包含其他项的定义，例如结构体、枚举、常量、特征，以及函数。\n通过模块系统，我们可以将相关定义分组并标注其关联性。使用这些代码的程序员能够根据分组导航代码，而无需逐行阅读所有定义，从而更轻松地定位目标功能。需要新增功能时，程序员也能明确代码存放位置以保持程序结构清晰。\n前文提到，src/main.rs 和 src/lib.rs 被称为 crate 根。其命名源于这两个文件的内容会构成名为 crate 的根模块，位于 crate 模块层级结构的顶端（即模块树(moudel tree)的根部）。\n模块树的分支就像下面这样：\n1 2 3 4 5 6 7 8 9 crate └── front_of_house ├── hosting │ ├── add_to_waitlist │ └── seat_at_table └── serving ├── take_order ├── serve_order └── take_payment 该树状图展示了模块间的嵌套关系（例如 hosting 嵌套在 front_of_house 中），同时揭示了同级模块的关系——如 hosting 与 serving 就是定义在 front_of_house 下的同级模块。当模块 A 包含于模块 B 时，我们称模块 A 是模块 B 的子模块(child moudel)，模块 B 则是模块 A 的父模块(parent moudel)。值得注意的是，整个模块树都以隐式的 crate 模块作为根节点。\n这种模块树结构会让人联想到计算机的文件系统目录树，这个类比非常贴切！正如用目录管理文件，我们用模块组织代码；而如同定位文件需要路径，访问模块也需要明确的路径规则。\n7.2 通过路径引用模块 在 Rust 中，我们需要通过路径来定位模块树中的特定项，就像在文件系统中使用路径导航一样。要调用某个函数，必须知道它的路径。\n路径有两种形式：\n绝对路径是从 crate 根开始的完整路径。对于外部 crate 的代码，绝对路径以 crate 名开头；对于当前 crate 的代码，则以字面量 crate 开头。 相对路径从当前模块开始，使用 self、super 或当前模块中的标识符。 无论是绝对路径还是相对路径，后面都会跟着一个或多个由双冒号(::)分隔的标识符。\n回到图例子，假设我们要调用 add_to_waitlist 函数。这就相当于问：add_to_waitlist 函数的路径是什么？\n我们将展示两种从 crate 根定义的新函数 eat_at_restaurant 中调用 add_to_waitlist 函数的方法。这些路径本身是正确的，但还存在另一个问题会导致当前示例无法通过编译，我们稍后会解释原因。\n**eat_at_restaurant 函数是我们库 crate 公共 API 的一部分，因此我们用 pub 关键字标记它。在 \u0026ldquo;使用 pub 关键字暴露路径\u0026rdquo; 一节中，我们将更详细地讨论 pub。在 src/libr.rs 中做如下修改（对 mod 做了一定简化）： **\n1 2 3 4 5 6 7 8 9 10 11 12 13 mod front_of_house { mod hosting { fn add_to_waitlist() {} } } pub fn eat_at_restaurant() { // 绝对路径 crate::front_of_house::hosting::add_to_waitlist(); //相对路径 front_of_house::hosting::add_to_waitlist(); } ​\t在 eat_at_restaurant 函数中第一次调用 add_to_waitlist 时，我们使用了绝对路径。由于 add_to_waitlist 与 eat_at_restaurant 定义在同一个 crate 中，因此可以使用 crate 关键字作为绝对路径的起点。我们依次包含各级模块，最终定位到 add_to_waitlist 函数。这就像在具有相同结构的文件系统中指定路径 /front_of_house/hosting/add_to_waitlist 来执行程序一样——用 crate 从 crate 根目录开始，就如同在 shell 中使用 / 从文件系统根目录开始导航。\n在 eat_at_restaurant 函数中第二次调用 add_to_waitlist 时，我们采用了相对路径的写法。这个路径以 front_of_house 模块名开头，该模块与 eat_at_restaurant 函数在模块树中属于同级关系。用文件系统来类比的话，这就相当于使用 front_of_house/hosting/add_to_waitlist 这样的相对路径。以模块名称开头的路径表明这是一个相对于当前模块的路径。\n选择使用相对路径还是绝对路径需要根据项目实际情况来决定，这主要取决于被调用项的定义代码和调用代码是否经常需要同步移动。举个例子：\n如果我们将 front_of_house 模块和 eat_at_restaurant 函数一起移动到名为 customer_experience 的新模块中： 绝对路径需要相应更新 但相对路径仍然有效 如果仅将 eat_at_restaurant 函数单独移动到 dining 模块： 绝对路径保持不变 但相对路径需要调整 一般来说，我们更倾向于使用绝对路径，因为在代码重构时，项的定义位置和调用位置往往需要独立调整。这就像在文件系统中使用绝对路径能更好地适应目录结构调整一样，能显著提升代码的可维护性。\n我们编译上述代码会发现：\n错误信息显示 hosting 模块是私有的。换句话说，虽然我们给出的 hosting 模块和 add_to_waitlist 函数的路径是正确的，但 Rust 不允许我们使用这些路径，因为它无法访问私有部分。在 Rust 中，所有项（函数、方法、结构体、枚举、模块和常量）默认对其父模块都是私有的。如果你想让某个项（比如函数或结构体）保持私有，只需将其放入模块中即可。\n父模块中的项不能使用子模块中的私有项，但子模块中的项可以使用其祖先模块中的项。这是因为子模块封装并隐藏了它们的实现细节，但子模块可以看到它们被定义的上下文环境。延续我们的比喻，可以将隐私规则想象成餐厅的后厨：对顾客来说后厨操作是私密的，但餐厅经理可以看到并操作整个餐厅的所有环节。\nRust 选择让模块系统以这种方式运作，是为了默认隐藏内部实现细节。这样你就能清楚地知道可以修改哪些内部代码而不会破坏外部代码。不过，Rust 也提供了通过 pub 关键字将子模块内部代码暴露给外部祖先模块的选项。\n7.2.2 使用 pub 关键字暴露路径 上面那个例子的解决方案就是给我们想要暴露的部分加上 pub 关键字：\n1 2 3 4 5 6 7 8 9 10 11 12 13 mod front_of_house { pub mod hosting { fn add_to_waitlist() {} } } pub fn eat_at_restaurant() { // 绝对路径 crate::front_of_house::hosting::add_to_waitlist(); // 相对路径 front_of_house::hosting::add_to_waitlist(); } 但是编译后发现依旧报错：\n这是因为，虽然我们使用 pub 关键字公开了 hosting，但是其内部的 add_to_waitlist 依旧是私有的。这就是我们前面提到的双重公开，我们想要调用 add_to_waitlist，必须也要在定义函数的时候加上 pub：\n1 2 3 4 5 6 7 8 9 10 11 12 13 mod front_of_house { pub mod hosting { pub fn add_to_waitlist() {}//加上 pub } } pub fn eat_at_restaurant() { // 绝对路径 crate::front_of_house::hosting::add_to_waitlist(); // 相对路径 front_of_house::hosting::add_to_waitlist(); } 再次编译就不会报错了。\n现在代码可以编译了！为了理解为什么加上 pub 就能在 eat_at_restaurant 中使用这些路径，我们来看看绝对路径和相对路径在隐私规则下的区别。\n在绝对路径中，我们从 crate 开始，也就是整个模块树的根。front_of_house 模块在 crate 根里定义。虽然 front_of_house 本身不是 pub，但因为 eat_at_restaurant 与它处于同一模块（即两者是兄弟），所以 eat_at_restaurant 可以直接提到 front_of_house。接下来，hosting 模块标记了 pub，我们可以访问它的父模块，于是也能访问 hosting。最后，add_to_waitlist 函数同样标记了 pub，我们自然可以调用它——整个调用链成立！\n在相对路径里，逻辑与绝对路径相同，只是第一步不同：路径不再从 crate 根开始，而是从 front_of_house 开始。front_of_house 就在 eat_at_restaurant 所在的模块里，因此以当前模块为起点写相对路径完全合法。又因为 hosting 和 add_to_waitlist 都标了 pub，后续路径畅通无阻，调用也有效！\n如果你打算把库 crate 分享给其他项目，那么公开的 API 就是你与使用者之间的“契约”，决定了他们如何与你的代码交互。关于如何管理公共 API 的变更，让下游依赖更轻松，还有很多细节可说，但这超出了本书范围；如果想深入了解，请参考 [The Rust API Guidelines](About - Rust API Guidelines)。\n7.2.3 使用 super 的相对路径 我们可以用 super 开头构建相对路径，使其从父模块而非当前模块或 crate 根开始查找。这种做法类似于文件系统里的 ..，表示“返回上一级目录”。借助 super，只要知道目标就在父模块里，我们就能直接引用；当该模块将来可能被移到模块树的其他位置时，这种写法也更容易整体搬迁。\n以这个场景为例：主厨发现订单出错，亲自更正后把餐点端给顾客。back_of_house 模块里的 fix_incorrect_order 函数需要调用定义在父模块中的 deliver_order，于是路径以 super 开头，指向父模块的 deliver_order：\n1 2 3 4 5 6 7 8 9 10 fn deliver_order() {} mod back_of_house { fn fix_incorrect_order() { cook_order(); super::deliver_order(); //super会让模块可以访问到自己父级模块的内容 } fn cook_order() {} } fix_incorrect_order 位于 back_of_house 模块，因此用 super 可以跳到它的父模块，也就是 crate 根。从那里再寻找 deliver_order 就能找到，调用成功！我们预期 back_of_house 模块与 deliver_order 函数之间的关系会保持稳定，未来若要重构模块树，它们大概率会一起移动。因此选用 super，日后只需改动更少的地方即可。\n7.2.4 在模块中定义公共的枚举和结构体 我们也可以把 pub 放在结构体和枚举的定义前，让它们成为公共类型，不过这里还有一些额外细节。如果给结构体整体加 pub，结构体本身对外可见，但它的成员默认仍然是私有的；你可以按需决定每个字段是否公开。\n以下示例中，我们定义了一个公共的 back_of_house::Breakfast：其中的 toast 字段公开，seasonal_fruit 字段私有。这模拟了餐厅里顾客可以挑选配餐面包，而具体搭配哪种水果由厨师根据当季库存决定。水果变化太快，顾客既无法选择，也无法提前知道会拿到什么：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 mod back_of_house { pub struct Breakfast { pub toast: String, seasonal_fruit: String, } impl Breakfast { pub fn summer(toast: \u0026amp;str) -\u0026gt; Breakfast { Breakfast { toast: String::from(toast), seasonal_fruit: String::from(\u0026#34;peaches\u0026#34;), } } } } pub fn eat_at_restaurant() { // 在夏天点一份黑麦吐司的早餐 let mut meal = back_of_house::Breakfast::summer(\u0026#34;Rye\u0026#34;); // 改变主意，换成全麦吐司 meal.toast = String::from(\u0026#34;Wheat\u0026#34;); println!(\u0026#34;I\u0026#39;d like {} toast please\u0026#34;, meal.toast); // 如果取消下面这行的注释，将无法编译：我们不能查看或修改随餐附赠的时令水果 // 因为该成员现在是私有的 // meal.seasonal_fruit = String::from(\u0026#34;blueberries\u0026#34;); } 因为 back_of_house::Breakfast 中的 toast 字段是公有的，所以在 eat_at_restaurant 里可以用点号对它进行读写。注意，我们无法在 eat_at_restaurant 里使用 seasonal_fruit 字段，因为它是私有的。试着把修改 seasonal_fruit 字段值的那一行取消注释，看看会得到什么错误！\n另外，由于 back_of_house::Breakfast 含有一个私有字段，该结构体必须提供一个公有的关联函数来构造 Breakfast 实例（这里我们把它命名为 summer）。如果没有这个函数，我们在 eat_at_restaurant 里就无法创建 Breakfast 的实例，因为无法在那里给私有的 seasonal_fruit 字段赋值。因为在没有 Defualt(之后了解)的情况下，我们必须显式指定每个结构体字段的值，但是我们又没办法访问 seasonal_fruit，所以需要一个函数来返回实例。\n但是与结构体不同的是，我们如果适用一个 pub 来声明一个枚举值，那么它的所有字段都会变成公共的。\n1 2 3 4 5 6 7 8 9 10 11 mod back_of_house { pub enum Appetizer { Soup, Salad, } } pub fn eat_at_restaurant() { let order1 = back_of_house::Appetizer::Soup; let order2 = back_of_house::Appetizer::Salad; } 由于我们把 Appetizer 枚举设为 pub，因此能在 eat_at_restaurant 中使用其 Soup 和 Salad 这两个变体。\n通常，除非枚举的变体是公开的，否则枚举就没什么用；要是在每个变体前都写 pub 会很烦人，因此枚举变体默认就是公共的。结构体则不同，即使字段不公开也常有价值，所以结构体字段遵循“默认私有”这一普遍规则，除非显式标注 pub。\n关于 pub，还有一种情况尚未提及，那就是模块系统的最后一个特性：use 关键字。我们先单独介绍 use，随后展示如何把它与 pub 结合使用。\n7.3 使用 use 将路径引入作用域 每次调用函数都要写出完整路径，既麻烦又重复。在之前的示例中，无论我们选绝对路径还是相对路径，只要想调用 add_to_waitlist ，就必须连带写 front_of_house:: hosting 。幸运的是，可以用 use 关键字一次性创建路径的“快捷方式”，之后在当前作用域里就能用更短的名字调用。\n在下面的示例中，我们把 crate::front_of_house::hosting 模块引入 eat_at_restauran t 函数的作用域，于是只需写 hosting::add_to_waitlist 即可调用 add_to_waitlist 。\n1 2 3 4 5 6 7 8 9 10 11 mod front_of_house { pub mod hosting { pub fn add_to_waitlist() {} } } use crate::front_of_house::hosting; pub fn eat_at_restaurant() { hosting::add_to_waitlist(); } 在当前作用域里写 use 和路径，就像在文件系统里创建一条符号链接。把 use crate::front_of_house::hosting; 加进 crate 根后，hosting 就成了该作用域里的合法名字，仿佛 hosting 模块就定义在 crate 根一样。通过 use 引入的路径同样会检查可见性，与其他路径无异。\n注意：use 只在它所出现的那一层作用域里建立快捷方式。下面把 eat_at_restaurant 函数移到一个新的子模块 customer 中，这就进入了与 use 语句不同的作用域，因此函数体将无法通过编译。\n1 2 3 4 5 6 7 8 9 10 11 12 13 mod front_of_house { pub mod hosting { pub fn add_to_waitlist() {} } } use crate::front_of_house::hosting; mod customer {// 使用了一个mod把函数调用包起来了，让use不再在函数调用中的作用域了 pub fn eat_at_restaurant() { hosting::add_to_waitlist(); } } 编译后如下报错：\n注意，编译器还会警告：这段 use 在它所在的作用域里并未被使用！解决办法有两种：把 use crate::front_of_house::hosting; 同样移到 customer 模块内部，或者在子模块 customer 里改用 super::hosting 来引用父模块中的这条快捷路径。\n7.3.2 创建符合自然语言习惯的 use 路径 在上述的第一个例子中，我们不禁好奇，使用 use 的时候为什么不直接 use crate::font_of_house::hosting::add_to_waitist，而是只到 hosting 为止？正如下面的这个例子一样：\n1 2 3 4 5 6 7 8 9 10 11 mod front_of_house { pub mod hosting { pub fn add_to_waitlist() {} } } use crate::front_of_house::hosting::add_to_waitlist; //直接引用到最后的函数 pub fn eat_at_restaurant() { add_to_waitlist(); } 虽然这个例子也能完成任务，但示例之前那种方法才是用 use 引入函数的惯用写法：把函数的父模块引入作用域，调用时仍需写出父模块前缀。这样既避免了重复完整路径，又一眼就能看出函数并非本地定义。本例子的写法让人难以判断 add_to_waitlist 到底定义在哪。\n另一方面，对于结构体、枚举等其他项，惯用法则是直接指定完整路径。下面展示了在二进制 crate 作用域中以惯用方式引入标准库的 HashMap 结构体。\n1 2 3 4 5 6 use std::collections::HashMap; fn main() { let mut map = HashMap::new(); map.insert(1, 2); } 这种写法并不是强制要求的，而是人们通俗约定的一种便于编写和阅读 Rust 代码的一种方式。而且这种编写方式可以避免有两个不同的模块拥有同样名称的一个方法或者内联函数：\n1 2 3 4 5 6 use std::fmt; use std::io; fn function1() -\u0026gt; fmt::Result {} fn function2() -\u0026gt; io::Result\u0026lt;()\u0026gt; {} 比如这两个函数就是，他们都需要返回一个 Result，但是由于这两个 Result 的所属的父级模块不同，所以其实他们不是同一种类型，这样加上父级模块，就能很好的规避这个问题。并且 Rust 也不允许这种多重定义的情况发生。\n7.3.3 使用 as 关键字为模块取别名 刚刚说的这种使用完整路径而导致冲突的情况，我们可以使用 as 关键字来将其中一个 Result 命名成其他的：\n1 2 3 4 5 6 use std::fmt::Result; use std::io::Result as IoResult; fn function1() -\u0026gt; Result {} fn function2() -\u0026gt; IoResult\u0026lt;()\u0026gt; {} 这样，我们就可以让编译器清楚的知道这两个是不同的类型。\n7.3.4 pub use 重新导出模块 当我们用 use 把某个名字导入作用域时，这个名字只在当前作用域内可见。如果想让外部代码也能像它在当前作用域定义一样地使用这个名字，可以把 pub 与 use 连用。这种写法称为“重导出”（re-export）：既把条目引入当前作用域，又让它可供其他模块再次导入：\n1 2 3 4 5 6 7 8 9 10 11 mod front_of_house { pub mod hosting { pub fn add_to_waitlist() {} } } pub use crate::front_of_house::hosting; pub fn eat_at_restaurant() { hosting::add_to_waitlist(); } 在改动之前，外部代码若想调用 add_to_waitlist 函数，必须写 restaurant::front_of_house::hosting::add_to_waitlist()，并且还得把 front_of_house 模块标成 pub。现在，借助这条 pub use 从根模块重新导出了 hosting，外部代码就能直接用 restaurant::hosting::add_to_waitlist() 来调用。\n重导出的意义在于：当代码的内部组织与使用者心目中的领域模型不一致时，可以用它做“翻译”。以餐厅为例，餐厅员工会把空间划分为“前厅”和“后厨”，但顾客并不会这么思考。通过 pub use，我们可以保留内部结构，同时向外暴露另一套更符合使用者直觉的 API。这样既方便库作者维护，又方便库用户调用。\n7.3.5 使用外部库 在第二章中，我们编写一个猜数游戏的时候，使用了一个随机数库 rand，我们将它添加到我们的 Cargo.toml 中。这让 Cargo 知道我们这个项目有哪些依赖，并且它会从 [crate.io](crates.io: Rust Package Registry)中下载这个库，并且让这个库在我们的项目中可以被使用。\n然后，我们使用 use 关键字将 rand 库中的 Rng 模块带入到了我们的作用域中。社区为 Rust 提供了特别多的外部库，我们可以使用相同的方法来引入其他的库。\n注意，标准库 std 其实也是一个外部的库，只是其与 Rust 一起分发，所以我们使用标准库的时候不需要在 Cargo.toml 中指定这个依赖，我们只需要在源文件中使用 use 来将其中我们想要使用的包给引入我们的作用域中即可；就比如如果我们想要使用标准库中的哈希——HashMap 时，我们只需要在程序中加上：\n1 use std::collections::HashMap// 从std开始的绝对路径 7.3.6 嵌套路径(Nested path) 如果我们想要使用同一个库中的多个模块，没一个模块都要使用一个 use 当然不太现实，就比如我们第二章的猜数游戏中使用标准库的两个模块的时候：\n1 2 use std::cmp::Ordering; use std::io; 对于这种情况，我们建议使用嵌套路径来引入模块：\n1 use std::{cmp::Ordering, io}; 我们先使用 :: 操作符将公共部分印出来，最后在 {} 之中分别引用各自需要的部分。这在大型项目中很有用处。我们可以在路径的任何级别使用嵌套路径，这在组合两个共享子路径的 use 语句时非常有用。比如下个例子，我们使用两个 use 将标准库的 std::io 和 std::io::Write 引入作用域：\n1 2 use std::io; use std::io::Write; 这两个模块的共同路径都是 std::io，所以我们可以合并成下面这样：\n1 use std::io::{self, Write}; 这里的 self 其实就是 std::io 本身，所以我们使用一个语句合并了两个语句。\n7.3.7 通配符(The Glob Operator) 如果我们想要将一个模块的所有公共项给引入我们的项目，我们可以使用通配符 *：\n1 use std::collections::*; 这条 use 语句会把 std::collections 中定义的所有公共项一次性引入当前作用域。使用通配符时必须小心！它会让“当前作用域里到底有哪些名字、这些名字最初定义在哪”变得难以判断。此外，一旦依赖项改变了其定义，你引入的内容也会随之变化；例如，升级依赖后，如果它新增了一个与你本地同名的定义，就可能导致编译错误。\n通配符常见于测试场景，用来把待测模块里的所有内容一次性导入 tests 模块；我们将在第 11 章中讨论这一点。通配符有时也会出现在“prelude 模式”中，如需了解该模式的详情，可查阅 [标准库文档](std::prelude - Rust)。\n7.2 模块化编程 目前为止，我们都在一个文件中定义不同的模块，但是在大型项目中，我们通常将不同功能的模块分别放到单独的一个文件中。\n就比如之前那个餐厅的例子，我们接下来会在不同文件中定义不同的模块，而不是都放在根 crate 文件中。在这个例子中，根 crate 是 src/lib.rs，但是程序在根 crate 为 src/main.rs 的情况下也依旧可以运行。\n首先，我们把 front_of_house 模块提取到单独的文件中。把原来 front_of_house 模块花括号里的代码全部删掉，只留下 mod front_of_house; 这条声明，使 src/lib.rs 变成示例所示的内容。注意这段代码还无法通过编译。\nFilename: src/lib.rs\n1 2 3 4 5 6 7 mod front_of_house; pub use crate::front_of_house::hosting; pub fn eat_at_restaurant() { hosting::add_to_waitlist(); } 接下来，把原先放在花括号里的代码移到新建的 src/front_of_house.rs 文件中。编译器之所以会去这个文件里找模块内容，是因为它在 crate 根遇到了名为 front_of_house 的模块声明。\nFilename: src/front_of_house.rs\n1 2 3 pub mod hosting { pub fn add_to_waitlist() {} } 注意：在整个模块树里，只需用 mod 声明一次文件即可。一旦编译器通过这条 mod 语句知道该文件属于项目，并确定了它在模块树中的位置，项目中的其他文件就应该用“路径”来引用这段代码，路径的起点是这条 mod 语句所在的位置，这在 7.2 一节已经讲过。换句话说，mod 并不像你在其他语言里见过的 “include” 操作那样简单地把文件内容原地插入。\n接下来，我们把 hosting 模块也提取到独立文件。由于 hosting 是 front_of_house 的子模块，而不是根模块的子模块，步骤稍有不同。我们需要在 src/front_of_house 目录下为它新建文件，目录名与它在模块树中的祖先路径保持一致。\n要开始移动 hosting，先把 src/front_of_house.rs 改成只保留对 hosting 模块的声明：\nFilename: src/front_of_house.rs\n1 pub mod hosting; 然后我们创建 src/front_of_house 目录，和一个 hosting.rs 去包含 hosting 模块内的一些定义：\nFilename: src/front_of_house/hosting.rs\n1 pub fn add_to_waitlist() {} 如果我们把 hosting.rs 直接放在 src 目录下，编译器就会认为它是 crate 根里声明的 hosting 模块，而不是 front_of_house 的子模块。编译器根据模块声明的位置去找对应文件，因此目录和文件结构必须与模块树完全一致。\n我们已经把每个模块的代码移到了单独的文件里，模块树本身保持不变。eat_at_restaurant 里的函数调用无需任何改动即可正常工作，尽管定义已分散在不同文件中。随着模块体积增大，这种“按文件拆分”的做法随时可用。\n注意，src/lib.rs 中的 pub use crate::front_of_house::hosting; 语句并未改变；use 也不会影响哪些文件被编译。真正决定模块归属的是 mod 关键字：Rust 会去寻找与模块同名的文件，并把其内容当作该模块的代码。\nRust 的模块系统把“声明位置 → 文件系统路径”做成了一条强规则：\n你在哪一级写 mod xxx;，编译器就在同级目录找 xxx.rs，或在同名目录 xxx/ 里找下一层子模块。 路径必须层层对齐，不能错位；一旦声明了子模块，父模块就必须升级为目录。 你不想拆文件时，可以直接在任何一级用花括号 mod xxx { ... } 就地实现；只要后续不再新增子模块，就无需改动目录。 一句话：“声明在哪，文件就在哪；有子模块就升目录，没子模块可留在花括号里。”\nChapter 8 常见的集合(Collections) Rust 的标准库包含一系列非常实用的数据结构，称为集合。大多数其他数据类型只代表单个特定值，而集合可以包含多个值。与内建的数组和元组类型不同，这些集合指向的数据存储在堆上，这意味着数据量无须在编译时就确定，可以在程序运行时增长或缩减。每种集合都有不同的能力与开销，根据当前场景选择合适的集合是一项会随着时间而提升的技能。在本章中，我们将讨论 Rust 程序中非常常用的三种集合：\n向量(vector)允许你存储可变数量的相邻值。 字符串(string)是字符的集合。我们之前提到过 String 类型，但在本章中将深入探讨。 哈希映射(hash map)允许你将值与特定键关联。它是更通用的数据结构——映射——的一种具体实现。 我们将讨论如何创建和更新向量、字符串和哈希映射，以及它们各自的独特之处。\n8.1 向量(vector) 向量允许我们在一个数据结构中存储多个值，他们在内存中的位置都是相邻的；并且向量只能存储一种数据类型的数据。我们用 Vec\u0026lt;T\u0026gt; 来表示。\n8.1.2 创建一个向量 就如我们之前学到的，对于一个数据类型，标准库中通常允许我们使用 new 方法来创建一个空的实例，所以我们使用以下的语句来创建一个空的向量实例：\n1 let v:Vec\u0026lt;i32\u0026gt; = Vec::new(); 注意到我们这里显式指定了向量的存储的数据类型，这是由于我们目前还没有给向量中存储任何数据，所以编译器并不知道这里的数据类型。这是因为向量中的 \u0026lt;T\u0026gt; 是一种泛型(generics)，我们将在第十章具体讨论泛型，我们现在只需要知道这是一种可以存储所有数据类型的一种表达。\n但是更多时候我们在声明一个向量的时候都是使用了初始值的方式，这个时候编译器就可以推断数据类型，所以我们就不需要显式指定数据类型，我们将初始值放到 [] 中，我们使用 vec![] 宏来操作这个过程：\n1 let v = vec![1,2,3];//编译器会推断 v:Vec\u0026lt;i32\u0026gt; 接下来我们来学习如何修改一个向量。\n8.1.3 向向量中增加数据 我们使用 push 方法来给一个已经创建的向量实例添加数据：\n1 2 3 4 5 let mut v = Vec::new(); v.push(1); v.push(2); v.push(3); 我们需要在声明的时候加上 mut，意味着这个向量是可变的，并且由于 1，2，3 这些都是默认的 i32，所以编译器可以推断出数据类型。\n8.1.4 获取向量中的值 想要引用向量中的值，总共有两种方式，第一种是使用索引值或者使用 get 方法。比如下面这个例子，我们就使用这两种方法来获取，为了更清晰的展示，我们将显式的指定数据类型：\n1 2 3 4 5 6 7 8 9 10 11 fn main() { let v: Vec\u0026lt;i32\u0026gt; = vec![1, 2, 3, 4, 5]; let third: \u0026amp;i32 = \u0026amp;v[2];// 直接使用索引值 println!(\u0026#34;The third element is {third}\u0026#34;); let third: Option\u0026lt;\u0026amp;i32\u0026gt; = v.get(2);// 使用get方法 match third { Some(Num) =\u0026gt; println!(\u0026#34;The third element is {Num}\u0026#34;), None =\u0026gt; println!(\u0026#34;The third element is none\u0026#34;), } } 我们使用索引值 2 来获取向量的第三个值，因为索引值总是从 0 开始的。我们使用 \u0026amp; 和 [] 来获取向量这个索引位置的值的引用。当我们使用 get 方法的时候，会返回一个 Option\u0026lt;T\u0026gt; 数据类型，所以我们要使用 match 来判断一下这个位置是不是有值。\n使用 get 方法访问到向量范围之外的索引会返回一个 None 值，那如果我们直接使用索引值会发生什么呢？\n1 2 3 4 5 6 fn main() { let v = vec![1, 2, 3, 4, 5]; let does_not_exist = \u0026amp;v[100]; let does_not_exist = v.get(100); } 当我们运行这段代码时，第一个 [] 方法会导致程序崩溃，因为它引用了一个不存在的元素。这个方法最适合在你希望程序在尝试访问向量末尾之外的元素时崩溃时使用。\n使用 get 方法就可以避免这个问题，但是我们需要在程序中加上处理 Some(\u0026amp;element) 或者 None 的逻辑。\n当程序拥有一个有效引用时，借用检查器会强制执行第 4 章中讲到的所有权与借用规则，以确保该引用以及任何指向向量内容的其他引用始终有效。回忆一下那条规则：在同一作用域内，不能同时存在可变引用和不可变引用。这条规则同样适用于：我们先持有一个指向向量首元素的不可变引用，然后又试图在向量末尾添加一个新元素。如果随后还在函数中再次使用该首元素的引用，这段程序将无法通过编译。\n1 2 3 4 5 6 fn main() { let mut v = vec![1, 2, 3, 4, 5]; let first = \u0026amp;v[0];//如果注释这句话就可以顺利编译，因为push是一个可变引用 v.push(6); println!(\u0026#34;The first element is: {first}\u0026#34;); } 编译后的结果是：\n示例的代码乍一看似乎应该能行：指向首元素的引用为什么要关心向量末尾的变化呢？这个错误源于向量的实现方式：由于向量把值连续地存放在内存里，当向量当前位置旁没有足够的空间时，再向末尾添加新元素就可能需要分配一块新内存，并把旧元素整体复制过去。在这种情况下，原先指向首元素的引用就会指向已被释放的内存。借用规则正是为了防止程序陷入这种境地而设计的。\n8.1.5 遍历向量中的值 和数组一样，我们可以使用 for 循环来遍历向量中的每一个值：\n1 2 3 4 5 6 7 fn main() { let v = vec![1, 2, 3, 4, 5]; for i in \u0026amp;v { println!(\u0026#34;{i}\u0026#34;); } } 也可以在遍历中修改一个可变向量中的值：\n1 2 3 4 5 6 7 8 fn main() { let mut v = vec![1, 2, 3, 4, 5]; for i in \u0026amp;mut v { *i += 50;//* 是解引用 println!(\u0026#34;{i}\u0026#34;); } } 在修改向量中的值之前，我们要使用 * 来解引用 i，依次来把存储在 i 中的值给取出来，然后进行修改。\n无论以不可变还是可变方式遍历向量，由于借用检查器的规则，整个过程都是安全的。如果我们尝试在 for 循环体中插入或删除元素，就会得到“可变引用和不可变引用”共存的编译错误。for 循环持有的对向量的引用会阻止同时修改整个向量，因为 for 本质也是一个不可变引用。\n8.1.6 枚举与向量 由于向量只能存储一种类型的数据，我们可以将向量与枚举结合起来，通过枚举的值来让向量中可以存在不同的类型，但是由于枚举其实只是一种数据类型，所以是可行的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 fn main() { enum SomeType { Int(i64), Float(f64), Text(String), } let v = vec![ SomeType::Int(9999), SomeType::Float(1.23456), SomeType::Text(String::from(\u0026#34;Hello Wolrd\u0026#34;)), ]; } Rust 需要在编译时就知道向量中会存放哪些类型，以便精确计算在堆上为每个元素分配多少内存。我们还必须显式指定该向量允许存放的类型。如果 Rust 允许一个向量持有任意类型，那么其中某些类型可能会在向量元素的操作中引发错误。借助枚举与 match 表达式，Rust 会在编译期确保所有可能情况都被处理，这一点在第 6 章已有讨论。\n如果在编译时并不知道程序运行时会遇到哪些类型并把它们存入向量，枚举技巧就派不上用场。此时可以使用 trait 对象，我们将在第 18 章讨论这一机制。\n既然我们已经探讨了使用向量的常见方法，请务必查阅标准库为 Vec\u0026lt;T\u0026gt; 定义的全部实用方法。例如，除了 push 之外，pop 方法可以移除并返回向量的最后一个元素。\n8.1.7 释放一个向量就会释放向量中的所有的值 当一个向量被释放时：\n1 2 3 4 5 6 fn main() { { let v = vec![1, 2, 3, 4]; // ... } // \u0026lt;- 超出v的作用域，v会被释放 } 当我们向量 v 被释放掉的时候，v 中所有的值都会被释放掉，意味着这些值会被清空借用检查器确保：任何指向向量内部元素的引用，只能在向量本身仍然有效的期间使用。\n8.2 字符串（String） 8.2.1 字符串存储的时 UTF-8 编码的文本 我们在第 4 章已经谈到过字符串，但现在需要更深入地探讨。Rust 初学者常在字符串上“翻车”，原因大体有三：Rust 倾向于把潜在错误暴露出来；字符串这种数据结构远比许多程序员想象的复杂；以及无处不在的 UTF-8。这些因素交织在一起，让从其他语言转过来的开发者感到棘手。\n之所以把字符串放在“集合”这一章讨论，是因为字符串本质上是一个字节集合，并附带一些方法，使得这些字节被解释为文本时能提供有用的功能。本节将介绍 String 作为集合类型所共有的操作：创建、更新、读取。我们也会讨论 String 与其他集合的差异，尤其是“按索引访问”在 String 上为何因人类与计算机对字符串数据的不同理解而变得复杂。\n首先，我们来明确“字符串”一词的含义。在 Rust 的核心语言中，只有一种字符串类型，即字符串切片 str，通常以借用的形式 \u0026amp;str 出现。第 4 章里讨论过，字符串切片是对别处存储的某段 UTF-8 编码数据的引用。例如，字符串字面量就被存放在程序的二进制文件中，因而也是字符串切片。\nString 类型则由 Rust 的标准库提供，而非直接内置在核心语言中。它是一种可增长、可变、拥有所有权的 UTF-8 编码字符串类型。当 Rustacean 提到 Rust 里的“字符串”时，可能指的是 String，也可能指的是字符串切片 \u0026amp;str，而不仅仅是其中一种。尽管本节主要围绕 String 展开，但 String 与 \u0026amp;str 在标准库中都极为常用，并且二者均采用 UTF-8 编码。\n8.2.2 创建一个 String 很多适用于向量的操作，同样也适用于 String，因为其实 String 其实也是一种存储字节的向量，只是带有其特殊的限制和功能。因此，创建一个 String 我们可以使用 new 方法来创建一个空白的实例：\n1 2 3 fn main(){ let mut s = String::new(); }\t对于想要在创建的时候就赋予其一个初始值，我们可以使用 to_string 方法。这个方法适用于所有实现了 Display 特性的数据类型；而字符串的面量就实现了这个特性：\n1 2 3 4 5 6 7 8 9 fn main() { let data = \u0026#34;initial contents\u0026#34;; // 这里的data编译器会推断为 \u0026amp;`static str let s = data.to_string(); // 该方法也可以直接对字符串面值实现: let s = \u0026#34;initial contents\u0026#34;.to_string(); } 同样，我们也可以使用 from 语句来创建一个有初始化的实例：\n1 2 3 fn main(){ let s = String::from(\u0026#34;Hello World\u0026#34;); }\t由于我们经常使用字符串，所以字符串有许多的公用 API 操作。虽然有些 API 看上去都在做同一件事，但是他们都有自己独特的作用。不过我们上述两个例子中的 to_string 和 from 确实都只是为了让 String 实例有一个初始值，选择哪种方式只是个人风格的问题。\n我们上文提到过，String 类型存储的是 UTF-8 数据类型，所以我们可以存储任何正确的编码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 fn main() { let hello = String::from(\u0026#34;السلام عليكم\u0026#34;); let hello = String::from(\u0026#34;Dobrý den\u0026#34;); let hello = String::from(\u0026#34;Hello\u0026#34;); let hello = String::from(\u0026#34;שלום\u0026#34;); let hello = String::from(\u0026#34;नमस्ते\u0026#34;); let hello = String::from(\u0026#34;こんにちは\u0026#34;); let hello = String::from(\u0026#34;안녕하세요\u0026#34;); let hello = String::from(\u0026#34;你好\u0026#34;); let hello = String::from(\u0026#34;Olá\u0026#34;); let hello = String::from(\u0026#34;Здравствуйте\u0026#34;); let hello = String::from(\u0026#34;Hola\u0026#34;); } 8.2.3 增加字符串 String 可以像 Vec\u0026lt;T\u0026gt; 一样增长和修改内容——只要你往里继续 push 数据。此外，你还可以方便地使用 + 运算符或 format! 宏来把多个 String 拼接在一起：\n1 2 3 4 5 6 7 8 fn main() { let mut s1 = String::from(\u0026#34;Hello\u0026#34;); s1.push_str(\u0026#34;, Rust\u0026#34;); // s1:Hello,Rust let s2 = String::from(\u0026#34;!\u0026#34;);\t//s2:! let s3 = s1 + \u0026amp;s2; // s3: Hello,Rust! let s4 = format!(\u0026#34;{} {}\u0026#34;, s3, \u0026#34;2025\u0026#34;); // s4: Hello,Rust! 2025 println!(\u0026#34;{}\u0026#34;, s4); // 输出: Hello, Rust! 2025 } 还有我们之前就使用过的 push_str，这个方法将一个字符串追加到目标字符串的后面，就如同上面的 s1.push_str(\u0026quot;, Rust\u0026quot;);，把“, Rust”追加到 s1 的后面。同样，我们也可以将另一个字符串变量的引用作为参数达到合并两个字符串的效果：\n1 2 3 4 5 6 fn main() { let mut s1 = String::from(\u0026#34;Hello\u0026#34;); let s2 = String::from(\u0026#34;, Rust\u0026#34;); s1.push_str(\u0026amp;s2); println!(\u0026#34;{s1}\u0026#34;);//打印 Hello Rust } String 中也存在 push 方法，只不过他只是将一个字符追加到字符串的后面：\n1 2 3 4 5 fn main() { let mut s1 = String::from(\u0026#34;Rus\u0026#34;); s1.push(\u0026#39;t\u0026#39;); //注意单个字符用单引号括起来 println!(\u0026#34;{s1}\u0026#34;);// 打印Rust } 8.2.4 + 操作符和 format! 宏 刚刚只是简单引入了这两个概念，接下来是更细节的信息。\n当我们想要连接两个字符串的时候，最常用的还是 + 操作：\n1 2 3 4 5 6 7 8 fn main() { let s1 = String::from(\u0026#34;Hello,\u0026#34;); let s2 = String::from(\u0026#34;World!\u0026#34;); let s3 = s1 + \u0026amp;s2; //s1的值在这里被移动 //println!(\u0026#34;{s1}\u0026#34;); //这是不允许的，因为s1的值已经被移动了 println!(\u0026#34;{s3}\u0026#34;);//打印 Hello,World! } 至于我们为什么不能再 + 操作符之后使用 s1 是并且 s2 要使用引用是因为，当我们调用 + 的时候，其本质是调用了 add 方法，而该方法的原型是类似于下面这样：\n1 fn add(self, s: \u0026amp;str) -\u0026gt; String {} 在标准库中，你会看到 add 的入参是泛型和关联类型。在这里，我们替换成了具体类型，这就是当我们用 String 值调用这个方法时发生的情况。\n首先，s2 前面有一个 \u0026amp;，表示我们把第二个字符串的引用拼接到第一个字符串上。这是因为 add 函数的第二个参数 s 的类型限制：只能把 \u0026amp;str 追加到 String，而不能把两个 String 直接相加。但等一下，\u0026amp;s2 的类型是 \u0026amp;String，并不是 add 函数签名中要求的 \u0026amp;str，那示例 8-18 为什么还能编译通过呢？\n原因是在调用 add 时，编译器会自动把 \u0026amp;String 强转（ coerce ）为 \u0026amp;str。具体做法是利用“解引用强制转换”（deref coercion）：在这里，\u0026amp;s2 被转换成 \u0026amp;s2[..]。第 15 章我们会更详细地讨论解引用强制转换。由于 add 并不会取得 s 参数的所有权，所以操作完成后 s2 依旧是一个有效的 String。\n其次，从函数签名可以看出，add 会取得 self 的所有权，因为 self 前面没有 \u0026amp;。这意味着示例中的 s1 会被移动到 add 调用里，此后 s1 就不再有效。因此，尽管 let s3 = s1 + \u0026amp;s2; 看起来像是把两个字符串都复制一遍再生成一个新字符串，实际上这条语句只拿走了 s1 的所有权，把 s2 的内容复制追加进去，然后把结果的所有权返回给 s3。换句话说，表面上看似大量复制，实则不然，其内部实现比拷贝更高效。\n当我们想要将多个字符串连接到一起，使用 + 就会显得很复杂：\n1 2 3 4 5 6 7 fn main() { let s1 = String::from(\u0026#34;tic\u0026#34;); let s2 = String::from(\u0026#34;tac\u0026#34;); let s3 = String::from(\u0026#34;toe\u0026#34;); let s = s1 + \u0026#34;-\u0026#34; + \u0026amp;s2 + \u0026#34;-\u0026#34; + \u0026amp;s3; } 现在，s 的值就是 tic-tac-toe，但是我们也说了，这是一个很复杂的操作，所以对于多字符串合并，我们使用的是 format! 宏：\n1 2 3 4 5 6 7 fn main() { let s1 = String::from(\u0026#34;tic\u0026#34;); let s2 = String::from(\u0026#34;tac\u0026#34;); let s3 = String::from(\u0026#34;toe\u0026#34;); let s = format!(\u0026#34;{s1}-{s2}-{s3}\u0026#34;); } 这段代码同样把 s 设为 \u0026quot;tic-tac-toe\u0026quot;。format! 宏的工作方式与 println! 类似，只是它不将结果输出到屏幕，而是返回一个包含内容的 String。使用 format! 的版本读起来要容易得多，而且 format! 宏生成的代码使用的是引用，因此这次调用不会夺取任何参数的所有权。\n8.2.5 String 中的索引 在很多编程语言中，想要获取一个字符串中的某个具体的字符，通常就是使用该字符在这个字符串中的索引来引用。但是你想在 Rust 中这么干，是不行的：\n1 2 3 4 fn main() { let s1 = String::from(\u0026#34;hi\u0026#34;); let h = s1[0]; } 编译这段代码，会发现如下报错：\n这个报错告诉我们，Rust 中的字符串并不支持使用索引值来访问。但是为什么呢？为了回答这个问题，我们要先从字符串在内存中的存储说起。\n8.2.6 字符串的内部表示 String 类型其实是包装在 Vec\u0026lt;u8\u0026gt; 上的一种结构，看看如下的 UTF-8 的字符串：\n1 2 3 4 5 6 7 8 9 10 11 12 13 fn main() { let hello = String::from(\u0026#34;السلام عليكم\u0026#34;); let hello = String::from(\u0026#34;Dobrý den\u0026#34;); let hello = String::from(\u0026#34;Hello\u0026#34;); let hello = String::from(\u0026#34;שלום\u0026#34;); let hello = String::from(\u0026#34;नमस्ते\u0026#34;); let hello = String::from(\u0026#34;こんにちは\u0026#34;); let hello = String::from(\u0026#34;안녕하세요\u0026#34;); let hello = String::from(\u0026#34;你好\u0026#34;); let hello = String::from(\u0026#34;Olá\u0026#34;); let hello = String::from(\u0026#34;Здравствуйте\u0026#34;); let hello = String::from(\u0026#34;Hola\u0026#34;); } 以 let hello = String::from(\u0026quot;Hola\u0026quot;); 为例，它的 len 是 4，意味着存储字符串“Hola”的向量占用 4 个字节。在 UTF-8 编码中，每一个字母都占用一个字节；然而，下一行可能会让你感到惊讶（请注意，这个字符串以大写的西里尔字母“Ze”开头，而不是数字 3）：\n1 let hello = String::from(\u0026#34;Здравствуйте\u0026#34;); 如果你被问及字符串的长度，你可能会说 12。实际上，Rust 的答案是 24：这是编码“Здравствуйте”为 UTF-8 所需的字节数，因为该字符串中的每个 Unicode 标量值需要 2 个字节的存储空间。因此，字符串字节的索引并不总是与有效的 Unicode 标量值对应。为了说明这一点，参考以下无效的 Rust 代码：\n1 2 let hello = \u0026#34;Здравствуйте\u0026#34;; let answer = \u0026amp;hello[0]; 你已经知道，answer 不会是 “З”——这个单词的第一个字母。当用 UTF-8 编码时，“З” 的第一个字节是 208，第二个字节是 151，所以看起来 answer 似乎应该是 208；然而 208 并不是一个有效的独立字符。如果用户想获取这个字符串的第一个字母，返回 208 显然不是他们想要的结果。即使字符串里只包含拉丁字母，用户通常也不希望返回字节值：假如 \u0026amp;\u0026quot;hi\u0026quot;[0] 是合法代码并返回字节值，那会得到 104，而不是字符 'h'。\n因此，Rust 的答案是：为了避免返回意外的值并在日后埋下难以察觉的 bug，这段代码根本不会被编译——在开发早期就把误解扼杀在摇篮里。\n8.2.7 字节(Byte)、标量值(Scalar Value)、字素簇(Grapheme Clusters) 关于 UTF-8 的另一个要点是：从 Rust 的角度来看，字符串实际上有三种相关的观察方式——字节（bytes）、标量值（scalar values）以及字素簇（grapheme clusters，最接近我们日常所说的“字母”）。\n以天城文书写的印地语单词 “नमस्ते” 为例，它在内存中存成一个 u8 向量，其字节序列如下：\n1 [224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164, 224, 165, 135] 这 18 个字节就是计算机如何存储这个单词的形式。如果我们使用 Unicode 中标量值的视角，即 Rust 中的 char 类型，这些字节长这样：\n1 [\u0026#39;न\u0026#39;, \u0026#39;म\u0026#39;, \u0026#39;स\u0026#39;, \u0026#39;्\u0026#39;, \u0026#39;त\u0026#39;, \u0026#39;े\u0026#39;] 这里有六个 char 值，但第四个和第六个不是字母：它们是变音符号，单独使用没有意义。最后，如果我们把它们看作是字素簇，我们就会得到一个人会称之为构成印地语单词的四个字母的东西：\n1 [\u0026#34;न\u0026#34;, \u0026#34;म\u0026#34;, \u0026#34;स्\u0026#34;, \u0026#34;ते\u0026#34;] Rust 提供了多种方式来解释计算机实际存储的原始字符串数据，从而让每个程序都能根据自己的需求选择合适的解释，无论这些数据属于何种人类语言。\nRust 不允许我们用索引直接获取 String 中字符的最后一个原因是：索引操作通常被期望在常数时间 O(1) 内完成。然而对于 String 来说，这一点无法保证——为了确定给定索引处到底有多少个有效字符，Rust 必须从字符串开头一路遍历到该位置。\n8.2.8 切片字符串 对字符串进行索引通常是个糟糕的主意，因为很难确定索引操作应该返回什么类型：字节值、单个字符、字素簇，还是字符串切片？因此，如果你真的需要用索引来创建字符串切片，Rust 要求你更明确一些。\n与其用单个数字的 [] 索引，不如用 [] 配合一个区间来创建包含特定字节的字符串切片：\n1 2 3 4 5 fn main() { let hello = \u0026#34;Здравствуйте\u0026#34;; let s = \u0026amp;hello[0..4]; } 这里，s 就是一个字符串切片 \u0026amp;str 类型，它包含了 hello 的前四个字节存储的字符。之前我们说过，“Здравствуйте”中的每个字母都占用两个字节，所以 s 就是 Зд。\n如果我们试图用类似 \u0026amp;hello[0..1] 的方式，只对某个字符的一部分字节进行切片，Rust 会在运行时直接 panic，效果就像在向量中用无效索引访问元素一样：\n1 2 3 4 5 fn main() { let hello = \u0026#34;Здравствуйте\u0026#34;; let s = \u0026amp;hello[0..1];//由于每个字母占用两个字节，第一个索引值是无意义的 } 编译结果如下：\n但是如果我们换成下列的代码又会是可行的了：\n1 2 3 4 5 fn main() { let hello = \u0026#34;Hello\u0026#34;; let s = \u0026amp;hello[0..1]; } 这是因为“Hello”中每一个字母只占用一个字节，所以第一个索引值是有意义的，此时的 s 其实就是字母 h。\n8.2.9 遍历字符串的方法 操作字符串片段的最佳方式是显式声明你到底想要“字符”还是“字节”。\n若要获取单个 Unicode 标量值（char），请使用 chars 方法。对字符串 \u0026quot;Зд\u0026quot; 调用 chars 会将其拆成两个 char，随后即可遍历结果来逐元素访问：\n1 2 3 4 5 6 7 8 9 10 11 fn main() { for c in \u0026#34;Зд\u0026#34;.chars() { println!(\u0026#34;{c}\u0026#34;); } } /* 打印： З д */ 相反，bytes 方法会返回原始的字节值：\n1 2 3 4 5 6 7 8 9 10 11 12 13 fn main() { for c in \u0026#34;Зд\u0026#34;.bytes() { println!(\u0026#34;{c}\u0026#34;); } } /* 打印： 208 151 208 180 */ 但务必记住：有效的 Unicode 标量值可能由不止一个字节组成。\n如果想从字符串中提取字素簇（例如天城文书写的文本），情况会更复杂，因此标准库并未提供这一功能。若你需要这种能力，可在 crates.io 上找到相应的 crate。\n8.2.10 字符串并不简单 总之，字符串确实复杂。不同语言在“如何把这种复杂性呈现给开发者”上做了不同取舍。Rust 选择把“正确处理 String 数据”设为所有程序的默认行为，这意味着开发者必须在一开始就认真考虑 UTF-8 数据的处理。这种权衡让 Rust 暴露出的字符串复杂度看起来比其他语言更高，但它能让你在后续开发生命周期中免于处理各种涉及非 ASCII 字符的错误。\n好消息是，标准库基于 String 和 \u0026amp;str 提供了大量开箱即用的功能，帮助你正确应对这些棘手场景。别忘了去查阅文档，像 contains（在字符串中搜索）和 replace（用另一段字符串替换部分内容）等方法都非常有用。\n接下来，让我们切换到不那么复杂的话题：哈希映射！\n8.3 哈希映射(Hash Map) 我们要介绍的最后一个常用集合是哈希映射（hash map）。HashMap\u0026lt;K, V\u0026gt; 类型通过哈希函数把类型为 K 的键映射到类型为 V 的值，并决定它们在内存中的存放位置。许多编程语言都支持这种数据结构，只是名称各不相同，例如 hash、map、object、hash table、dictionary 或 associative array 等。\n当你不想用向量那样的整数索引，而是想用任意类型的键来查询数据时，哈希映射就非常有用。例如，在游戏中，你可以用哈希映射来记录各队得分：键是队名，值是该队的分数。给定队名即可快速查到对应分数。\n本节仅介绍哈希映射的基本 API，但标准库在 HashMap\u0026lt;K, V\u0026gt; 上还提供了大量实用功能。一如既往，请查阅标准库文档获取更多信息。\n8.3.2 创建一个哈希映射 我们使用 new 方法创建一个空的哈希映射，使用 insert 方法来给一个已经存在的哈希映射添加元素。下面我们使用哈希映射来持续追踪两个队的得分，假设黄队初始分数为 50，蓝队的初始分数为 10：\n1 2 3 4 5 6 7 fn main() { use std::collections::HashMap; let mut scores = HashMap::new(); scores.insert(String::from(\u0026#34;Blue\u0026#34;), 10); scores.insert(String::from(\u0026#34;Yellow\u0026#34;), 50); } 由于相比起向量和字符串，哈希映射使用的最少，所以它并不会自动被包含到我们的项目中。我们想要使用哈希映射首先需要使用 use 将哈希映射给带入我们的作用域。并且标准库对于哈希映射的支持也比较少，就比如没有任何类似 vec![] 和 format! 的宏来处理哈希映射。\n和向量一样，哈希映射也是在堆上存储。我们这个例子中，该哈希的键是 String 类型，值是 i32 类型；和向量一样，在一个哈希中，所有的键值对的数据类型必须是一致的，也就是说键必须是同一种类型，值也必须是同一种类型。\n8.3.3 获取哈希中的值 我们可以使用 get 方法来获取一个哈希中的值。\n1 2 3 4 5 6 7 8 9 10 11 fn main() { use std::collections::HashMap; let mut scores = HashMap::new(); scores.insert(String::from(\u0026#34;Blue\u0026#34;), 10); scores.insert(String::from(\u0026#34;Yellow\u0026#34;), 50); let team_name = String::from(\u0026#34;Blue\u0026#34;); let score = scores.get(\u0026amp;team_name).copied().unwrap_or(0); } 这行代码中，score最后会得到哈希中键Blue所对应的值，也就是10。get方法返回的值是Option\u0026lt;\u0026amp;V\u0026gt;，如果这个位置没有值，就会返回None。这里使用copied方法获得Option\u0026lt;i32\u0026gt;而不是Option\u0026lt;\u0026amp;i32\u0026gt;，然后使用unwrap_or：如果 scores里没有这条键，就把 score设为 0。\n[!NOTE]\ncopied 是定义在 Option 和 Iterator 上的适配器方法，用来把引用里的值复制一份，从而把 Option\u0026lt;\u0026amp;T\u0026gt;（或迭代器里的 \u0026amp;T）变成 Option\u0026lt;T\u0026gt;（或迭代器里的 T）。\n在 Option 上的签名 1 2 3 4 5 impl\u0026lt;T\u0026gt; Option\u0026lt;\u0026amp;T\u0026gt; { pub fn copied(self) -\u0026gt; Option\u0026lt;T\u0026gt; where T: Copy; } 作用：把 Option\u0026lt;\u0026amp;T\u0026gt; 转成 Option\u0026lt;T\u0026gt;。 前提：T 必须实现 Copy（如 i32、bool、char 等简单类型）。 典型用法 1 2 3 4 5 6 7 8 use std::collections::HashMap; let mut map = HashMap::new(); map.insert(\u0026#34;Blue\u0026#34;, 10); let score: i32 = map.get(\u0026#34;Blue\u0026#34;) // Option\u0026lt;\u0026amp;i32\u0026gt; .copied() // Option\u0026lt;i32\u0026gt; .unwrap_or(0); // 没有就返回 0 如果不加 .copied()，map.get(\u0026quot;Blue\u0026quot;) 得到的是 Option\u0026lt;\u0026amp;i32\u0026gt;，直接 unwrap_or(0) 会因为类型不匹配而报错。\n与 cloned 的区别 copied 要求 T: Copy，只做按位复制，速度快。 cloned 要求 T: Clone，会执行 Clone::clone，允许更复杂的复制逻辑。 简单类型优先用 copied；需要深拷贝或自定义复制逻辑时用 cloned。\n8.3.4 哈希映射与所有权 对于实现了 Copy 特质的类型，比如 i32 ，值会被复制到哈希映射中。对于像 String 这样的拥有值，值会被移动，哈希映射将成为这些值的拥有者：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 fn main() { use std::collections::HashMap; let field_name = String::from(\u0026#34;最喜欢的颜色\u0026#34;); let field_value = String::from(\u0026#34;蓝色\u0026#34;); let stack_only_key = 10; let stack_only_value = 1; let mut map1 = HashMap::new(); let mut map2 = HashMap::new(); map1.insert(field_name, field_value); map2.insert(stack_only_key, stack_only_value); // println!(\u0026#34;{field_name}:{field_value}\u0026#34;); //解除这段话的注释会报错 println!(\u0026#34;{stack_only_key}:{stack_only_value}\u0026#34;) } 如果解除注释之后再编译，会发现如下报错：\n温习一下之前的关于仅栈数据(stack-only data)的内容，对于类似于i32这样的只存在于栈上的数据，是实现了copy trait的，意味着它可以在栈上快速创建副本，所以在值传递的时候是传递的副本，而不是所有权的转交，而像字符串这样比较复杂数据类型，那么传递值就是通过所有权转交。所以我们这里field_name和field_value在传入给哈希之后，所有权就哈希所有，我们在后面就不能调用它了。\n如果我们向哈希映射中插入值的引用，这些值不会被移动到哈希映射中。引用指向的值必须至少在哈希映射有效期间保持有效。\n8.3.5 更新哈希映射 虽然键值对可以一直增长，但是每个键只能有一个值，但是同一个值可以有多个键。例如，蓝队和黄队都可以在哈希表 scores 中存储值 10\n当你想修改哈希映射中的数据时，必须决定“键已存在”时的策略：\n直接覆盖旧值——完全忽略旧值，用新值替代。 保留旧值——仅当键不存在时才插入新值，已存在则保持原样。 合并更新——把旧值与新值按某种规则合并后再存回去。 接下来我们逐一演示这三种做法。\n8.3.5.1 覆写数据 当我们使用insert尝试在一个原有值的键中插入一个新值，这个新值就会直接覆盖掉原来的值：\n1 2 3 4 5 6 7 8 9 10 fn main() { use std::collections::HashMap; let mut scores = HashMap::new(); scores.insert(String::from(\u0026#34;Blue\u0026#34;), 10); scores.insert(String::from(\u0026#34;Blue\u0026#34;), 25); println!(\u0026#34;{scores:?}\u0026#34;);// 打印{\u0026#34;Blue\u0026#34;: 25} } 比如这里，虽然Blue插入了两次值，但是他只会存储最新的值，也就是25。\n8.3.5.2 当一个键不存在的时候再添加新的键值对 一种常见需求是：先检查哈希映射中某个键是否已经存在值，然后按以下规则处理——如果键已存在，保持原值不变；如果键不存在，则插入该键并设定对应值。\n哈希映射为此提供了专门的 API：entry。它接收你想检查的键作为参数，返回一个名为 Entry 的枚举，表示该键对应的值可能存在，也可能不存在。\n假设我们想检查 Yellow 队对应的键是否已有值：如果没有，就插入值 50；对 Blue 队也做同样处理。\n1 2 3 4 5 6 7 8 9 10 11 12 fn main() { use std::collections::HashMap; let mut scores = HashMap::new(); scores.insert(String::from(\u0026#34;Blue\u0026#34;), 10); scores.entry(String::from(\u0026#34;Yellow\u0026#34;)).or_insert(50); scores.entry(String::from(\u0026#34;Blue\u0026#34;)).or_insert(50); println!(\u0026#34;{scores:?}\u0026#34;);//打印 {\u0026#34;Yellow\u0026#34;: 50, \u0026#34;Blue\u0026#34;: 10} } Entry类型中的or_insert的作用是，如果这个键有值，则会返回这个值的可变引用；如果没有，则会插入它接收的入参作为该键的值，并且返回这个新值的可变引用。\n运行的代码将打印 {\u0026quot;Yellow\u0026quot;: 50, \u0026quot;Blue\u0026quot;: 10}。\n第一次调用 entry 时，由于 Yellow 队尚无对应值，会把键 Yellow 连同值 50 插入哈希映射；\n第二次调用 entry 时，Blue 队已存在值 10，因此哈希映射保持不变。\n8.3.5.3 基于旧值更新 哈希映射的另一个常见用法是：先查某个键对应的值，再基于旧值做更新。\n示例的代码就展示了这种场景：统计一段文本里每个单词出现的次数。我们把单词作为键存入哈希映射，每遇到一次就把值加 1；若首次遇到该单词，则先插入初始值 0：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 fn main() { use std::collections::HashMap; let text = \u0026#34;hello world wonderful world\u0026#34;; let mut map = HashMap::new(); for word in text.split_whitespace() { //将字符串通过空格分隔开 //这里的每个word都是字符串切片类型 \u0026amp;str let count = map.entry(word).or_insert(0); *count += 1; } println!(\u0026#34;{map:?}\u0026#34;); } 这段代码会打印出 {\u0026quot;world\u0026quot;: 2, \u0026quot;hello\u0026quot;: 1, \u0026quot;wonderful\u0026quot;: 1}。你可能看到同样的键值对以不同顺序输出：回忆一下“获取哈希中的值”一节，遍历哈希映射的顺序是任意的。\nsplit_whitespace 方法会返回一个迭代器，按空白字符把 text 切分成多个子切片。or_insert 方法返回指定键所对应值的可变引用（\u0026amp;mut V）。在这里，我们把该可变引用存进 count 变量，因此要想修改这个值，必须先使用星号（*）对 count 进行解引用。在 for 循环结束时，该可变引用离开作用域，因此所有这些改动都是安全的，也符合借用规则。\n8.3.6 哈希函数 默认情况下，HashMap 使用名为 SipHash 的哈希函数，它能抵御针对哈希表的拒绝服务（DoS）攻击。这并不是最快的哈希算法，但为换取更高的安全性而牺牲一些性能，这种权衡通常是值得的。\n如果你在性能剖析中发现默认哈希函数过慢，可以通过指定另一个 hasher（实现 BuildHasher trait 的类型）来切换算法。第 10 章将介绍 trait 及其实现方式。你不必从零自己实现 hasher；crates.io 上已有许多社区共享的库，提供了多种常见哈希算法的现成 hasher。\n8.4 课后训练 1. 给定一个整数列表，使用向量并返回中位数和众数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 use std::collections::HashMap; fn main() { let v = vec![1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 6, 6, 6, 6, 6, 6, 6, 6]; let res = get_mid_mode(\u0026amp;v); println!(\u0026#34;{res:?}\u0026#34;); } fn get_mid_mode(list: \u0026amp;Vec\u0026lt;i32\u0026gt;) -\u0026gt; HashMap\u0026lt;String, i32\u0026gt; { let mut map = HashMap::new(); let mut temp = HashMap::new(); let mut max_times = 0;//最高出现次数 let mut max_num = 0;//最高出现次数的数 //统计所有数的出现次数 for i in list { //注意， i其实是\u0026amp;i32类型 let count = temp.entry(i.to_string()).or_insert(0); // 返回值是可变引用 所以修改这个值要使用解引用* *count += 1; if *count \u0026gt; max_times { max_times = *count; //基于 copy trait 这里是复制了一份 *count的值来存储 max_num = *i; //同上 } } //添加众数 map.entry(String::from(\u0026#34;Mode\u0026#34;)).or_insert(max_num); let mid_count = list.len() / 2; //中值的索引值 //添加中值到哈希中 map.entry(String::from(\u0026#34;Median\u0026#34;)).or_insert(list[mid_count]); return map; } /* 打印： {\u0026#34;Mode\u0026#34;: 6, \u0026#34;Median\u0026#34;: 4} /* ","date":"2025-08-21T00:00:00Z","image":"https://example.com/p/rust-self-teach/rust-2_hu_48bd07b65295672c.jpg","permalink":"https://example.com/p/rust-self-teach/","title":"Rust自学笔记"},{"content":"串口通信模块使用说明 概述 本模块实现了一个功能完整的串口通信系统，支持环形缓冲区数据管理、DMA数据传输、格式化输出以及数据帧解析功能。适用于STM32等嵌入式系统的串口通信需求。\n源码下载地址 Serial.c Serial.h 功能特性 ✅ 环形缓冲区管理：高效的数据缓存与处理机制 ✅ DMA数据传输：支持DMA发送和接收，提高传输效率 ✅ 格式化输出：提供类似printf的格式化输出功能 ✅ 数据帧解析：自动解析数据帧，支持校验功能 ✅ 指令提取：从数据帧中提取有效指令数据 ✅ 可配置参数：支持多种配置选项 文件结构 1 2 3 4 串口格式化发送+环形缓冲区/ ├── Serial.h # 头文件，包含宏定义和函数声明 ├── Serial.c # 实现文件，包含所有功能实现 └── README.md # 本使用说明文档 配置参数 基本配置 (Serial.h) 1 2 3 #define USER_UART \u0026amp;huart1 // 指定使用的串口 #define RX_TX_BUFFERS 255 // 发送/接收缓存大小 #define CIRCULAR_BUFFER_ENABLE 0 // 启用环形缓冲区 (0=禁用, 1=启用) 环形缓冲区配置 1 2 3 4 5 #define DATAPACK_HEAD 0xAA // 数据包头标识 #define CHECKSUM_ENABLE 1 // 校验功能 (1=启用, 0=禁用) #define CMD_MIN_LENGTH 4 // 指令最小长度 (自动计算) #define CMD_MAX_LENGTH 255 // 指令最大长度 #define CIRCLBUFFERS_SIZE 255 // 环形缓冲区大小 数据帧格式 启用校验位时 1 2 | 包头(1byte) | 长度(1byte) | 数据(n bytes) | 校验位(1byte) | | 0xAA | 数据长度 | 有效数据 | 校验和 | 不启用校验位时 1 2 | 包头(1byte) | 长度(1byte) | 数据(n bytes) | | 0xAA | 数据长度 | 有效数据 | 注意：长度字段表示整个数据帧的长度，包括包头、长度字段本身、数据和校验位。\nAPI接口 1. 格式化输出函数 MyPrintf() 1 uint16_t MyPrintf(UART_HandleTypeDef *huart, const char *format, ...); 功能：格式化串口输出，类似printf函数 参数： huart - 使用的串口句柄 format - 格式化字符串 \u0026hellip; - 可变参数 返回值：实际发送的字节数 示例： 1 MyPrintf(\u0026amp;huart1, \u0026#34;温度: %d°C, 湿度: %d%%\\r\\n\u0026#34;, temperature, humidity); MyPrintf_DMA() 1 uint16_t MyPrintf_DMA(UART_HandleTypeDef *huart, const char *format, ...); 功能：通过DMA格式化串口输出 参数： huart - 使用的串口句柄 format - 格式化字符串 \u0026hellip; - 可变参数 返回值：实际发送的字节数 示例： 1 MyPrintf_DMA(\u0026amp;huart1, \u0026#34;系统状态: %s\\r\\n\u0026#34;, status_str); 2. 环形缓冲区函数 Buffer_Write() 1 uint8_t Buffer_Write(uint8_t *Data, uint8_t Length); 功能：向环形缓冲区写入数据 参数：Data - 数据指针，Length - 数据长度 返回值：实际写入的字节数，0表示缓冲区空间不足 示例： 1 2 uint8_t data[] = {0x01, 0x02, 0x03}; uint8_t result = Buffer_Write(data, sizeof(data)); Buffer_Read() 1 uint8_t Buffer_Read(BufferType_t *Command); 功能：从环形缓冲区读取一个完整的指令 参数：Command - 未使用（可传入NULL） 返回值：指令数据长度，0表示没有找到有效指令 示例： 1 2 3 4 5 6 7 uint8_t cmd_length = Buffer_Read(NULL); if (cmd_length \u0026gt; 0) { // 处理Serial_Command数组中的指令数据 for (int i = 0; i \u0026lt; cmd_length - 2; i++) { // 处理Serial_Command[i] } } 3. 外部变量 Serial_Command[] 1 extern uint8_t Serial_Command[CMD_MAX_LENGTH - (CHECKSUM_ENABLE ? 3 : 2)]; 功能：存储解析出的指令数据（不包含包头、长度和校验位） 使用：当Buffer_Read()返回值大于0时，该数组包含有效的指令数据 RxCplt_Flag 1 extern FlagStatus RxCplt_Flag; 功能：数据接收完成标志位（仅在CIRCULAR_BUFFER_ENABLE=0时使用） 使用：检查是否有新数据接收完成 RxSerial_Buffer[] 1 extern uint8_t RxSerial_Buffer[RX_TX_BUFFERS]; 功能：串口接收缓冲区 Serial_Idle_Handler() 1 void Serial_Idle_Handler(void); 功能：串口空闲中断处理函数（仅在CIRCULAR_BUFFER_ENABLE=0时使用） 使用：在串口空闲中断中调用此函数来处理接收到的数据 使用步骤 1. 硬件配置 配置STM32的UART外设 启用DMA（推荐） 配置串口参数（波特率、数据位等） 启用串口空闲中断（普通缓冲区模式需要） 2. 中断配置 在CubeMX中或代码中配置串口空闲中断：\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 启用串口空闲中断 __HAL_UART_ENABLE_IT(USER_UART, UART_IT_IDLE); // 在中断服务函数中处理 void USART1_IRQHandler(void) { if(__HAL_UART_GET_FLAG(USER_UART, UART_FLAG_IDLE)) { __HAL_UART_CLEAR_IDLEFLAG(USER_UART); Serial_Idle_Handler(); } HAL_UART_IRQHandler(USER_UART); } 3. 软件集成 包含头文件 1 #include \u0026#34;Serial.h\u0026#34; 配置参数 根据需求修改Serial.h中的配置宏定义\n初始化串口接收\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 启动DMA接收 HAL_UARTEx_ReceiveToIdle_DMA(USER_UART, RxSerial_Buffer, sizeof(RxSerial_Buffer)); // 在串口空闲中断中调用处理函数（普通缓冲区模式） void USART1_IRQHandler(void) { // 检测空闲中断 if(__HAL_UART_GET_FLAG(USER_UART, UART_FLAG_IDLE)) { __HAL_UART_CLEAR_IDLEFLAG(USER_UART); Serial_Idle_Handler(); } HAL_UART_IRQHandler(USER_UART); } 4. 使用模式 模式1：普通缓冲区模式 (默认) 设置 CIRCULAR_BUFFER_ENABLE = 0\n1 2 3 4 5 6 7 8 9 10 void main_loop() { if (RxCplt_Flag == SET) { RxCplt_Flag = RESET; // 处理RxSerial_Buffer中的数据 process_raw_data(RxSerial_Buffer); } // 发送数据 MyPrintf(\u0026amp;huart1, \u0026#34;状态更新: %d\\r\\n\u0026#34;, system_status); } 模式2：环形缓冲区模式 (推荐用于复杂协议) 设置 CIRCULAR_BUFFER_ENABLE = 1\n1 2 3 4 5 6 7 8 9 10 void main_loop() { uint8_t cmd_length = Buffer_Read(NULL); if (cmd_length \u0026gt; 0) { // 处理接收到的指令 process_command(Serial_Command, cmd_length - (CHECKSUM_ENABLE ? 3 : 2)); } // 发送数据 MyPrintf_DMA(\u0026amp;huart1, \u0026#34;状态更新: %d\\r\\n\u0026#34;, system_status); } 数据发送示例 发送标准数据帧 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 void send_command(uint8_t cmd, uint8_t *data, uint8_t data_len) { uint8_t frame[256]; uint8_t frame_len = 0; // 构建数据帧 frame[frame_len++] = DATAPACK_HEAD; // 包头 frame[frame_len++] = data_len + (CHECKSUM_ENABLE ? 4 : 3); // 总长度 frame[frame_len++] = cmd; // 命令 // 添加数据 for (uint8_t i = 0; i \u0026lt; data_len; i++) { frame[frame_len++] = data[i]; } // 添加校验位（如果启用） if (CHECKSUM_ENABLE) { uint8_t checksum = 0; for (uint8_t i = 1; i \u0026lt; frame_len; i++) { checksum += frame[i]; } frame[frame_len++] = checksum; } // 发送数据帧 HAL_UART_Transmit_DMA(\u0026amp;huart1, frame, frame_len); } 应用示例 温度传感器数据发送 1 2 3 4 5 6 7 8 9 10 void send_temperature_data() { float temperature = 25.6; uint8_t temp_data[4]; // 将浮点数转换为字节数组 memcpy(temp_data, \u0026amp;temperature, sizeof(float)); // 发送温度数据 send_command(0x01, temp_data, sizeof(temp_data)); } 指令处理示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 void process_received_command() { uint8_t cmd_length = Buffer_Read(NULL); if (cmd_length \u0026gt; 0) { uint8_t command = Serial_Command[0]; switch (command) { case 0x01: // 查询温度 send_temperature_data(); break; case 0x02: // 设置参数 if (cmd_length \u0026gt;= 3) { uint8_t param = Serial_Command[1]; uint8_t value = Serial_Command[2]; set_parameter(param, value); } break; default: MyPrintf(\u0026amp;huart1, \u0026#34;未知命令: 0x%02X\\r\\n\u0026#34;, command); break; } } } 注意事项 内存管理：确保CIRCLBUFFERS_SIZE设置合理，避免溢出 DMA配置：正确配置DMA中断和回调函数 校验功能：根据通信可靠性需求选择是否启用校验 线程安全：在多线程环境中注意数据访问的同步 错误处理：建议添加适当的错误处理机制 串口句柄：使用格式化输出函数时需要传入正确的串口句柄 空闲中断：在普通缓冲区模式下需要正确配置和处理串口空闲中断 故障排除 常见问题 数据接收不完整\n检查DMA配置是否正确 确认串口参数匹配 检查缓冲区大小是否足够 校验失败\n确认发送端和接收端校验算法一致 检查数据传输过程中是否有丢失或错误 缓冲区溢出\n增大CIRCLBUFFERS_SIZE 提高数据处理频率 优化数据处理算法 空闲中断不触发\n检查NVIC中断配置是否正确 确认空闲中断标志位清除方法正确 验证Serial_Idle_Handler()是否被正确调用 版本信息 作者：N1ntyNine99 版本：v1.0 日期：2025-04-17 更新日期：2025-07-27 许可证 本模块代码仅供学习和参考使用。\n","date":"2025-08-21T00:00:00Z","image":"https://example.com/p/%E4%B8%B2%E5%8F%A3/pic3_hu_952e55dfb8b63a0b.jpg","permalink":"https://example.com/p/%E4%B8%B2%E5%8F%A3/","title":"串口格式化发送+环形缓冲区"},{"content":"MyFilter - 嵌入式信号处理滤波器库 一个轻量级、高性能的嵌入式信号处理滤波器库，提供四种常用的数字滤波器实现，适用于各种嵌入式系统的信号处理需求。\n源码下载 MyFilter.c MyFilter.h 📦 功能特性 低通滤波器 (Low Pass Filter) - 一阶 IIR 滤波器，计算简单，实时性好 中值滤波器 (Median Filter) - 有效抑制脉冲噪声，保持信号边缘 均值滤波器 (Moving Average) - 平滑随机噪声，计算效率高 卡尔曼滤波器 (Kalman Filter) - 最优估计算法，自适应调整 🏗️ 文件结构 1 2 3 4 MyFilter/ ├── MyFilter.h # 头文件 - 结构体定义和函数声明 ├── MyFilter.c # 实现文件 - 滤波器算法实现 └── README.md # 说明文档 🔧 快速开始 1. 包含头文件 1 #include \u0026#34;MyFilter.h\u0026#34; 2. 初始化滤波器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 低通滤波器初始化 lowpass_filter_t lpf; LowPass_Filter_Init(\u0026amp;lpf, 0.8f); // 系数0.8，强滤波 // 中值滤波器初始化 midvalue_filter_t mvf; MidValue_Filter_Init(\u0026amp;mvf, 5); // 窗口大小5 // 均值滤波器初始化 average_filter_t avgf; Avg_Filter_Init(\u0026amp;avgf, 10); // 10个样本 // 卡尔曼滤波器初始化 kalman_filter_t kf; Kalman_Filter_Init(\u0026amp;kf, 0.1f, 1.0f, 0.0f); // Q=0.1, R=1.0, 初始值=0 3. 实时滤波处理 1 2 3 4 5 6 7 8 9 10 float sensor_value = read_sensor(); // 读取传感器原始数据 // 应用各种滤波器 LowPass_Filter(\u0026amp;lpf, sensor_value); MidValue_Filter(\u0026amp;mvf, sensor_value); Avg_Filter(\u0026amp;avgf, sensor_value); Kalman_Filter(\u0026amp;kf, sensor_value); // 获取滤波结果 float filtered_value = kf.KF_Res; // 使用卡尔曼滤波结果 📊 滤波器对比指南 滤波器类型 适用场景 优点 缺点 计算复杂度 低通滤波 一般噪声抑制 计算简单，内存占用少 相位延迟 O(1) 中值滤波 脉冲噪声抑制 有效去除异常值 需要缓冲区 O(n log n) 均值滤波 随机噪声平滑 简单有效 响应较慢 O(n) 卡尔曼滤波 最优估计 自适应，精度高 参数调优复杂 O(1) ⚙️ 参数配置 低通滤波器参数 1 2 3 4 // 滤波系数选择指南： LowPass_Filter_Init(\u0026amp;filter, 0.1f); // 轻滤波 - 实时控制 LowPass_Filter_Init(\u0026amp;filter, 0.5f); // 中等滤波 - 一般应用 LowPass_Filter_Init(\u0026amp;filter, 0.8f); // 强滤波 - 传感器去噪 中值滤波器参数 1 2 3 4 // 窗口大小选择： MidValue_Filter_Init(\u0026amp;filter, 3); // 快速响应 - 图像处理 MidValue_Filter_Init(\u0026amp;filter, 7); // 平衡效果 - 一般应用 MidValue_Filter_Init(\u0026amp;filter, 11); // 强滤波 - 严重噪声 卡尔曼滤波器参数 1 2 3 4 // 噪声协方差调优： Kalman_Filter_Init(\u0026amp;filter, 0.01f, 0.1f, 0.0f); // 高精度传感器 Kalman_Filter_Init(\u0026amp;filter, 0.1f, 1.0f, 0.0f); // 中等精度传感器 Kalman_Filter_Init(\u0026amp;filter, 1.0f, 10.0f, 0.0f); // 低精度传感器 🎯 应用示例 传感器数据滤波 1 2 3 4 5 6 7 8 9 // 温度传感器滤波 lowpass_filter_t temp_filter; LowPass_Filter_Init(\u0026amp;temp_filter, 0.7f); float read_temperature(void) { float raw_temp = read_adc() * 0.1f; // 原始数据 LowPass_Filter(\u0026amp;temp_filter, raw_temp); return temp_filter.LF_Res; // 滤波后的温度 } 电机控制信号平滑 1 2 3 4 5 6 7 8 // 电机控制信号处理 average_filter_t motor_filter; Avg_Filter_Init(\u0026amp;motor_filter, 5); void set_motor_speed(float speed) { Avg_Filter(\u0026amp;motor_filter, speed); analog_write(MOTOR_PIN, motor_filter.AF_Res); // 平滑后的速度 } IMU 数据融合 1 2 3 4 5 6 7 8 // 陀螺仪数据卡尔曼滤波 kalman_filter_t gyro_filter; Kalman_Filter_Init(\u0026amp;gyro_filter, 0.001f, 0.1f, 0.0f); float filter_gyro(float raw_gyro) { Kalman_Filter(\u0026amp;gyro_filter, raw_gyro); return gyro_filter.KF_Res; // 优化后的角速度 } ⚠️ 使用注意事项 内存分配：所有滤波器使用静态内存，无需动态分配 实时性：考虑最坏情况下的执行时间（中值滤波耗时最长） 初始化：使用前必须调用初始化函数 参数范围：注意各参数的有效范围，避免异常值 数据类型：使用 float 类型，确保平台支持浮点运算 🔧 性能优化建议 根据需求选择滤波器：不要过度设计，选择最简单的有效滤波器 合理设置参数：根据信号特性调整滤波器参数 缓冲区大小：在效果和内存之间找到平衡点 采样率匹配：滤波器参数应与系统采样率相匹配 📝 API 参考 低通滤波器 LowPass_Filter_Init() - 初始化低通滤波器 LowPass_Filter() - 执行低通滤波 中值滤波器 MidValue_Filter_Init() - 初始化中值滤波器 MidValue_Filter() - 执行中值滤波 均值滤波器 Avg_Filter_Init() - 初始化均值滤波器 Avg_Filter() - 执行均值滤波 卡尔曼滤波器 Kalman_Filter_Init() - 初始化卡尔曼滤波器 Kalman_Filter() - 执行卡尔曼滤波 📊 资源占用 代码大小: ~3KB (取决于启用哪些滤波器) RAM 占用: 约 100-200 字节（取决于配置） 计算时间: 低通/卡尔曼: O(1), 均值: O(n), 中值: O(n log n) 🐛 故障排除 问题: 滤波效果不明显\n解决: 调整滤波器参数，增大滤波强度 问题: 响应速度太慢\n解决: 减小窗口大小或滤波系数 问题: 内存占用过大\n解决: 减小缓冲区大小，使用更简单的滤波器 📄 许可证 MIT License - 可自由用于个人和商业项目。\n👥 作者信息 N1ntyNine99 - 嵌入式系统开发者\n💡 提示: 在实际使用前，建议根据具体的应用场景和硬件平台进行参数调优和性能测试。\n","date":"2025-08-21T00:00:00Z","image":"https://example.com/p/%E6%BB%A4%E6%B3%A2%E5%99%A8/pic5_hu_dfa5fbcf04e1ba8d.jpg","permalink":"https://example.com/p/%E6%BB%A4%E6%B3%A2%E5%99%A8/","title":"滤波器"},{"content":"内存池管理库 (Pool.c/Pool.h) 源码下载 Pool.c Pool.h 概述 一个轻量级固定大小内存块管理库，适用于嵌入式系统或高频内存分配场景。通过预分配内存和双向链表管理，提供高效的内存分配与释放功能。\n功能特性 ✅ 固定块大小内存管理 ✅ 双向链表维护空闲块 ✅ 内存碎片合并优化 ✅ 内存池完整性检查 ✅ 清零分配的内存块 快速开始 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 初始化内存池（块大小64字节，1024个块） if(!MemPool_Init(64, 1024)) { // 错误处理 } // 分配内存 void* ptr = MemPool_Malloc(128); // 分配128字节（2个块） // 使用内存... // 释放内存 MemPool_Free(ptr); // 销毁内存池 MemPool_Deinit(); API参考 初始化/销毁 函数 描述 MemPool_Init() 初始化内存池 MemPool_Deinit() 释放内存池资源 内存操作 函数 描述 MemPool_Malloc() 分配内存 MemPool_Free() 释放内存 设计优势 高效分配 - O(1)时间复杂度分配单个块 碎片合并 - 自动合并相邻空闲块 安全校验 - 包含内存池完整性检查 预分配机制 - 避免运行时内存碎片 使用限制 ⚠️ 仅支持固定块大小分配\n⚠️ 非线程安全\n⚠️ 初始化后无法动态扩展\n典型应用场景 嵌入式系统内存管理 网络数据包缓冲 实时任务调度 高频内存分配/释放场景 示例配置 1 2 #define MEMPOOL_BLOCK_SIZE 64 // 每个块64字节 #define MEMPOOL_BLOCK_NUM 1024 // 共1024个块 性能提示 🔹 分配单个块比多个连续块更快\n🔹 释放时会自动合并相邻空闲块\n🔹 调试时可启用DEBUG宏进行检查\n1 2 3 4 5 6 7 8 9 10 11 这个MD文件包含了： 1. 基本介绍 2. 快速使用示例 3. 核心API说明 4. 技术优势 5. 使用限制 6. 应用场景建议 7. 配置和性能提示 格式清晰，可以直接保存为README.md用于项目文档，或根据需要调整内容。 ","date":"2025-08-21T00:00:00Z","image":"https://example.com/p/%E5%86%85%E5%AD%98%E6%B1%A0/pic6_hu_a90bfb3dba11e375.png","permalink":"https://example.com/p/%E5%86%85%E5%AD%98%E6%B1%A0/","title":"嵌入式系统内存池"},{"content":"Task Scheduler 任务调度器 一个轻量级、可配置的任务调度管理系统，专为嵌入式系统设计。支持多任务定时调度、优先级管理、动态调整和低功耗模式。\n📋 功能特性 多任务管理：支持最多 20 个并发任务 优先级调度：数值越小优先级越高（0 为最高优先级） 动态时间调整：可根据任务执行时间自动调整调度间隔（可选） 低功耗支持：在空闲时进入低功耗模式（可选） 任务状态管理：支持激活、暂停、删除等状态控制 性能监控：实时监控每个任务的最大执行时间 🏗️ 系统架构 源码下载 下载 Task.h 下载 Task.c 文件结构 1 2 3 4 project/ ├── Task.h # 头文件 - 类型定义和函数声明 ├── Task.c # 实现文件 - 核心调度逻辑 └── main.c # 用户应用代码 核心数据结构 1 2 3 4 5 6 7 8 9 10 11 typedef struct { const char *Name; // 任务名称 uint32_t LastWakeUp; // 上一次唤醒时间 uint16_t MaxUsed; // 最大执行时间(ms) uint16_t Interval; // 执行间隔(ms) uint8_t Priority; // 优先级 task_ea_t State; // 任务状态 uint8_t CreationIndex; // 创建顺序 void *Para; // 函数参数 taskFunction_t Function; // 任务函数指针 } task_t; 🔧 快速开始 1. 包含头文件 1 #include \u0026#34;Task.h\u0026#34; 2. 定义任务函数 1 2 3 4 5 6 7 8 9 10 void LED_Task(void *para) { // LED 控制逻辑 HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_5); } void Sensor_Read_Task(void *para) { // 传感器读取逻辑 float *temperature = (float *)para; *temperature = read_temperature(); } 3. 添加任务到调度器 1 2 3 4 5 6 7 float temp_value = 0.0f; // 添加LED闪烁任务，每500ms执行一次，优先级为1 Task_Add(\u0026#34;LED\u0026#34;, LED_Task, 500, NULL, 1); // 添加温度读取任务，每1000ms执行一次，优先级为2 Task_Add(\u0026#34;Temperature\u0026#34;, Sensor_Read_Task, 1000, \u0026amp;temp_value, 2); 4. 在主循环中启动调度器 1 2 3 4 5 6 7 int main(void) { // 系统初始化... while (1) { Task_Start(HAL_GetTick); // 传入系统时钟获取函数 } } ⚙️ 配置选项 在 Task.h 中修改以下宏定义：\n1 2 3 4 5 #define DYNAMIC_MODIFY 0 // 动态调整功能 (0:关闭, 1:开启) #define LOW_POWER 0 // 低功耗模式 (0:关闭, 1:开启) #define MAXTASKS 20 // 最大任务数量 #define MIN_SLEEP_TICK 10 // 最小休眠时间(ms) #define TASK_ADJUST 5 // 任务调整力度(ms) 📖 API 参考 任务管理 Task_Add() - 添加新任务 Task_Delete() - 删除任务 Task_Suspend() - 暂停任务 Task_Resume() - 恢复任务 状态查询 Task_CheckNum() - 获取当前任务数量 Task_GetMaxUsed() - 获取任务最大执行时间 调度控制 Task_Start() - 启动任务调度（在主循环中调用） 🎯 使用示例 基本使用 1 2 3 4 5 6 7 8 9 10 11 12 // 定义任务函数 void MyTask(void *para) { printf(\u0026#34;Task executed!\\n\u0026#34;); } // 添加任务 Task_Add(\u0026#34;PrintTask\u0026#34;, MyTask, 1000, NULL, 1); // 主循环 while (1) { Task_Start(HAL_GetTick); } 带参数的任务 1 2 3 4 5 6 7 8 9 10 11 12 typedef struct { uint8_t id; uint16_t data; } sensor_data_t; void SensorTask(void *para) { sensor_data_t *data = (sensor_data_t *)para; data-\u0026gt;data = read_sensor_value(data-\u0026gt;id); } sensor_data_t sensor1 = {1, 0}; Task_Add(\u0026#34;Sensor1\u0026#34;, SensorTask, 200, \u0026amp;sensor1, 2); ⚠️ 注意事项 时间精度：依赖准确的系统时钟，建议使用硬件定时器 任务执行时间：单个任务执行时间不应超过最小任务间隔 优先级冲突：同优先级任务按创建顺序执行 中断安全：非线程安全，不要在中断中调用API函数 内存占用：每个任务占用约 32 字节内存 🔍 性能优化建议 启用动态调整：设置 DYNAMIC_MODIFY 1 自动优化任务间隔 合理设置优先级：关键任务设置更高优先级 使用低功耗模式：在电池供电设备中设置 LOW_POWER 1 监控任务耗时：定期检查 MaxUsed 避免任务超时 📊 版本信息 v2.0 (2025-08-17): 增强时间溢出处理，优化性能监控 v1.0 (2025-04-17): 初始版本，基础调度功能 👥 作者信息 N1ntyNine99 - 电子爱好者\n💡 提示: 在实际使用前，请根据您的硬件平台调整系统时钟获取函数（如 HAL_GetTick()）。\n","date":"2025-08-21T00:00:00Z","image":"https://example.com/p/%E8%B0%83%E5%BA%A6%E5%99%A8/pic8_hu_57f1d17e9231b0f4.jpg","permalink":"https://example.com/p/%E8%B0%83%E5%BA%A6%E5%99%A8/","title":"任务调度器"}]